encapsulated package AbsynJLDumpTpl
"
  file:        AbsynJLDumpTpl.mo
  package:     AbsynJLDumpTpl
  description: Generated by Susan.
"

public import Tpl;

public import Absyn;
public import AbsynUtil;
public import Util;
public import Config;
public import Dump;
public import System;
public import Flags;

public function dump
  input Tpl.Text txt;
  input Absyn.Program a_program;

  output Tpl.Text out_txt;
algorithm
  out_txt := dump2(txt, a_program, Dump.defaultDumpOptions);
end dump;

protected function lm_10
  input Tpl.Text in_txt;
  input list<Absyn.Class> in_items;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_options)
    local
      Tpl.Text txt;
      list<Absyn.Class> rest;
      Dump.DumpOptions a_options;
      Absyn.Class i_cls;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_cls :: rest,
           a_options )
      equation
        txt = dumpClass(txt, i_cls, a_options);
        txt = Tpl.nextIter(txt);
        txt = lm_10(txt, rest, a_options);
      then txt;
  end match;
end lm_10;

public function dump2
  input Tpl.Text in_txt;
  input Absyn.Program in_a_program;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_program, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      list<Absyn.Class> i_classes;
      Absyn.Within i_within__;
      Tpl.Text l_cls__str;
      Tpl.Text l_within__str;

    case ( txt,
           Absyn.PROGRAM(classes = {}, within_ = i_within__),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PROGRAM(list(), "));
        txt = dumpWithin(txt, i_within__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.PROGRAM(within_ = i_within__, classes = i_classes),
           a_options )
      equation
        l_within__str = dumpWithin(Tpl.emptyTxt, i_within__);
        l_cls__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                                     ", <%\n",
                                                                                     "%>"
                                                                                 }, false)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_cls__str = lm_10(l_cls__str, i_classes, a_options);
        l_cls__str = Tpl.popIter(l_cls__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PROGRAM(list("));
        txt = Tpl.writeText(txt, l_cls__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_within__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dump2;

public function dumpClass
  input Tpl.Text in_txt;
  input Absyn.Class in_a_cls;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cls, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      SourceInfo i_info;
      Absyn.ClassDef i_body;
      Absyn.Restriction i_restriction;
      Boolean i_encapsulatedPrefix;
      Boolean i_finalPrefix;
      Boolean i_partialPrefix;
      Absyn.Ident i_name;
      Tpl.Text l_i;
      Tpl.Text l_cd;
      Tpl.Text l_r;
      Tpl.Text l_ep;
      Tpl.Text l_fp;
      Tpl.Text l_pp;
      Tpl.Text l_n;

    case ( txt,
           Absyn.CLASS(name = i_name, partialPrefix = i_partialPrefix, finalPrefix = i_finalPrefix, encapsulatedPrefix = i_encapsulatedPrefix, restriction = i_restriction, body = i_body, info = i_info),
           a_options )
      equation
        l_n = Tpl.writeStr(Tpl.emptyTxt, i_name);
        l_pp = dumpFinal(Tpl.emptyTxt, i_partialPrefix);
        l_fp = dumpFinal(Tpl.emptyTxt, i_finalPrefix);
        l_ep = dumpFinal(Tpl.emptyTxt, i_encapsulatedPrefix);
        l_r = dumpRestriction(Tpl.emptyTxt, i_restriction);
        l_cd = dumpClassDef(Tpl.emptyTxt, i_body, a_options);
        l_i = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CLASS(\""));
        txt = Tpl.writeText(txt, l_n);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = Tpl.writeText(txt, l_pp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_fp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" ,"));
        txt = Tpl.writeText(txt, l_ep);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_r);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cd);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_i);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dumpClass;

protected function lm_13
  input Tpl.Text in_txt;
  input list<String> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<String> rest;
      String i_typevar;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_typevar :: rest )
      equation
        txt = Tpl.writeStr(txt, i_typevar);
        txt = Tpl.nextIter(txt);
        txt = lm_13(txt, rest);
      then txt;
  end match;
end lm_13;

protected function lm_14
  input Tpl.Text in_txt;
  input list<Absyn.Annotation> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Annotation> rest;
      Absyn.Annotation i_a;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_a :: rest )
      equation
        txt = dumpAnnotation(txt, i_a);
        txt = Tpl.nextIter(txt);
        txt = lm_14(txt, rest);
      then txt;
  end match;
end lm_14;

protected function lm_15
  input Tpl.Text in_txt;
  input list<Absyn.ClassPart> in_items;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_options)
    local
      Tpl.Text txt;
      list<Absyn.ClassPart> rest;
      Dump.DumpOptions a_options;
      Absyn.ClassPart i_class__part;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_class__part :: rest,
           a_options )
      equation
        txt = dumpClassPart(txt, i_class__part, a_options);
        txt = Tpl.nextIter(txt);
        txt = lm_15(txt, rest, a_options);
      then txt;
  end match;
end lm_15;

protected function lm_16
  input Tpl.Text in_txt;
  input list<Absyn.NamedArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.NamedArg> rest;
      Absyn.NamedArg i_e;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_e :: rest )
      equation
        txt = dumpNamedArg(txt, i_e);
        txt = Tpl.nextIter(txt);
        txt = lm_16(txt, rest);
      then txt;
  end match;
end lm_16;

protected function lm_17
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> rest;
      Absyn.ElementArg i_arg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_arg :: rest )
      equation
        txt = dumpElementArg(txt, i_arg);
        txt = Tpl.nextIter(txt);
        txt = lm_17(txt, rest);
      then txt;
  end match;
end lm_17;

protected function lm_18
  input Tpl.Text in_txt;
  input list<Absyn.ClassPart> in_items;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_options)
    local
      Tpl.Text txt;
      list<Absyn.ClassPart> rest;
      Dump.DumpOptions a_options;
      Absyn.ClassPart i_class__part;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_class__part :: rest,
           a_options )
      equation
        txt = dumpClassPart(txt, i_class__part, a_options);
        txt = Tpl.nextIter(txt);
        txt = lm_18(txt, rest, a_options);
      then txt;
  end match;
end lm_18;

protected function lm_19
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> rest;
      Absyn.ElementArg i_mod;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_mod :: rest )
      equation
        txt = dumpElementArg(txt, i_mod);
        txt = Tpl.nextIter(txt);
        txt = lm_19(txt, rest);
      then txt;
  end match;
end lm_19;

protected function fun_20
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_a_modifications;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_modifications)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> i_modifications;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_modifications )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_19(txt, i_modifications);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end fun_20;

protected function lm_21
  input Tpl.Text in_txt;
  input list<Absyn.Annotation> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Annotation> rest;
      Absyn.Annotation i_a;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_a :: rest )
      equation
        txt = dumpAnnotation(txt, i_a);
        txt = Tpl.nextIter(txt);
        txt = lm_21(txt, rest);
      then txt;
  end match;
end lm_21;

protected function lm_22
  input Tpl.Text in_txt;
  input list<Absyn.Path> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Path> rest;
      Absyn.Path i_fn;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_fn :: rest )
      equation
        txt = dumpPath(txt, i_fn);
        txt = Tpl.nextIter(txt);
        txt = lm_22(txt, rest);
      then txt;
  end match;
end lm_22;

public function dumpClassDef
  input Tpl.Text in_txt;
  input Absyn.ClassDef in_a_cdef;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cdef, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      list<Absyn.Path> i_functionNames;
      Absyn.EnumDef i_enumLiterals;
      Absyn.Ident i_baseClassName;
      list<Absyn.ElementArg> i_modifications;
      list<Absyn.ClassPart> i_parts;
      Option<Absyn.Comment> i_comment_1;
      list<Absyn.ElementArg> i_arguments;
      Absyn.TypeSpec i_typeSpec;
      Absyn.ElementAttributes i_attributes;
      list<Absyn.NamedArg> i_classAttrs;
      list<Absyn.ClassPart> i_classParts;
      Option<String> i_comment;
      list<Absyn.Annotation> i_ann;
      list<String> i_typeVars;
      Tpl.Text l_funcs__str;
      Tpl.Text l_enum__str;
      list<Absyn.Annotation> ret_9;
      Tpl.Text l_mod__str;
      Tpl.Text l_arg__str;
      Tpl.Text l_ty__str;
      Tpl.Text l_attr__str;
      Tpl.Text l_body__str;
      Tpl.Text l_cmt__str;
      list<Absyn.Annotation> ret_2;
      Tpl.Text l_ann__str;
      Tpl.Text l_tvs__str;

    case ( txt,
           Absyn.PARTS(typeVars = i_typeVars, ann = i_ann, comment = i_comment, classParts = i_classParts, classAttrs = i_classAttrs),
           a_options )
      equation
        l_tvs__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_tvs__str = lm_13(l_tvs__str, i_typeVars);
        l_tvs__str = Tpl.popIter(l_tvs__str);
        ret_2 = listReverse(i_ann);
        l_ann__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_ann__str = lm_14(l_ann__str, ret_2);
        l_ann__str = Tpl.popIter(l_ann__str);
        l_cmt__str = dumpStringCommentOption(Tpl.emptyTxt, i_comment);
        l_body__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_body__str = lm_15(l_body__str, i_classParts, a_options);
        l_body__str = Tpl.popIter(l_body__str);
        l_attr__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_attr__str = lm_16(l_attr__str, i_classAttrs);
        l_attr__str = Tpl.popIter(l_attr__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PARTS(list("));
        txt = Tpl.writeText(txt, l_tvs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_attr__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_body__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_ann__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.DERIVED(attributes = i_attributes, typeSpec = i_typeSpec, arguments = i_arguments, comment = i_comment_1),
           _ )
      equation
        l_attr__str = dumpElementAttr(Tpl.emptyTxt, i_attributes);
        l_ty__str = dumpTypeSpec(Tpl.emptyTxt, i_typeSpec);
        l_arg__str = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("("));
        l_arg__str = Tpl.pushIter(l_arg__str, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_arg__str = lm_17(l_arg__str, i_arguments);
        l_arg__str = Tpl.popIter(l_arg__str);
        l_arg__str = Tpl.writeTok(l_arg__str, Tpl.ST_STRING(")"));
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("DERIVED("));
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_attr__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_arg__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.CLASS_EXTENDS(parts = i_parts, modifications = i_modifications, comment = i_comment, ann = i_ann, baseClassName = i_baseClassName),
           a_options )
      equation
        l_body__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_body__str = lm_18(l_body__str, i_parts, a_options);
        l_body__str = Tpl.popIter(l_body__str);
        l_mod__str = fun_20(Tpl.emptyTxt, i_modifications);
        l_cmt__str = dumpStringCommentOption(Tpl.emptyTxt, i_comment);
        ret_9 = listReverse(i_ann);
        l_ann__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_ann__str = lm_21(l_ann__str, ret_9);
        l_ann__str = Tpl.popIter(l_ann__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CLASS_EXTENDS("));
        txt = Tpl.writeStr(txt, i_baseClassName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_mod__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_body__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_ann__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.ENUMERATION(enumLiterals = i_enumLiterals, comment = i_comment_1),
           _ )
      equation
        l_enum__str = dumpEnumDef(Tpl.emptyTxt, i_enumLiterals);
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ENUMERATION("));
        txt = Tpl.writeText(txt, l_enum__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.OVERLOAD(functionNames = i_functionNames, comment = i_comment_1),
           _ )
      equation
        l_funcs__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_funcs__str = lm_22(l_funcs__str, i_functionNames);
        l_funcs__str = Tpl.popIter(l_funcs__str);
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OVERLOAD(list("));
        txt = Tpl.writeText(txt, l_funcs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.PDER(functionName = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT SUPPORTED???"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dumpClassDef;

protected function lm_24
  input Tpl.Text in_txt;
  input list<Absyn.EnumLiteral> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.EnumLiteral> rest;
      Absyn.EnumLiteral i_lit;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_lit :: rest )
      equation
        txt = dumpEnumLiteral(txt, i_lit);
        txt = Tpl.nextIter(txt);
        txt = lm_24(txt, rest);
      then txt;
  end match;
end lm_24;

public function dumpEnumDef
  input Tpl.Text in_txt;
  input Absyn.EnumDef in_a_enum__def;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_enum__def)
    local
      Tpl.Text txt;
      list<Absyn.EnumLiteral> i_enumLiterals;
      Tpl.Text l_els;

    case ( txt,
           Absyn.ENUMLITERALS(enumLiterals = i_enumLiterals) )
      equation
        l_els = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_els = lm_24(l_els, i_enumLiterals);
        l_els = Tpl.popIter(l_els);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ENUMLITERALS(list("));
        txt = Tpl.writeText(txt, l_els);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.ENUM_COLON() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ENUM_COLON()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpEnumDef;

public function dumpEnumLiteral
  input Tpl.Text in_txt;
  input Absyn.EnumLiteral in_a_lit;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_lit)
    local
      Tpl.Text txt;
      Absyn.Ident i_literal;
      Option<Absyn.Comment> i_comment;
      Tpl.Text l_cmt__str;

    case ( txt,
           Absyn.ENUMLITERAL(comment = i_comment, literal = i_literal) )
      equation
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ENUMLITERAL("));
        txt = Tpl.writeStr(txt, i_literal);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpEnumLiteral;

protected function fun_27
  input Tpl.Text in_txt;
  input Absyn.FunctionRestriction in_a_functionRestriction;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_functionRestriction)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.FR_NORMAL_FUNCTION(purity = Absyn.IMPURE()) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FR_NORMAL_FUNCTION(IMPURE())"));
      then txt;

    case ( txt,
           Absyn.FR_NORMAL_FUNCTION(purity = Absyn.PURE()) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FR_NORMAL_FUNCTION(PURE())"));
      then txt;

    case ( txt,
           Absyn.FR_NORMAL_FUNCTION(purity = Absyn.NO_PURITY()) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FR_NORMAL_FUNCTION(NO_PURITY())"));
      then txt;

    case ( txt,
           Absyn.FR_OPERATOR_FUNCTION() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FR_OPERATOR_FUNCTION()"));
      then txt;

    case ( txt,
           Absyn.FR_PARALLEL_FUNCTION() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FR_PARALLEL_FUNCTION()"));
      then txt;

    case ( txt,
           Absyn.FR_KERNEL_FUNCTION() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FR_KERNEL_FUNCTION()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end fun_27;

public function dumpRestriction
  input Tpl.Text in_txt;
  input Absyn.Restriction in_a_restriction;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_restriction)
    local
      Tpl.Text txt;
      Absyn.FunctionRestriction i_functionRestriction;
      Tpl.Text l_prefix__str;

    case ( txt,
           Absyn.R_CLASS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_CLASS()"));
      then txt;

    case ( txt,
           Absyn.R_OPTIMIZATION() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_OPTIMIZATION()"));
      then txt;

    case ( txt,
           Absyn.R_MODEL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_MODEL()"));
      then txt;

    case ( txt,
           Absyn.R_RECORD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_RECORD()"));
      then txt;

    case ( txt,
           Absyn.R_BLOCK() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_BLOCK()"));
      then txt;

    case ( txt,
           Absyn.R_CONNECTOR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_CONNECTOR()"));
      then txt;

    case ( txt,
           Absyn.R_EXP_CONNECTOR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_EXP_CONNECTOR()"));
      then txt;

    case ( txt,
           Absyn.R_TYPE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_TYPE()"));
      then txt;

    case ( txt,
           Absyn.R_PACKAGE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_PACKAGE()"));
      then txt;

    case ( txt,
           Absyn.R_FUNCTION(functionRestriction = i_functionRestriction) )
      equation
        l_prefix__str = fun_27(Tpl.emptyTxt, i_functionRestriction);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_FUNCTION("));
        txt = Tpl.writeText(txt, l_prefix__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.R_OPERATOR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_OPERATOR()"));
      then txt;

    case ( txt,
           Absyn.R_OPERATOR_RECORD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_OPERATOR_RECORD()"));
      then txt;

    case ( txt,
           Absyn.R_ENUMERATION() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_ENUMERATION()"));
      then txt;

    case ( txt,
           Absyn.R_PREDEFINED_INTEGER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_PREDEFINED_INTEGER()"));
      then txt;

    case ( txt,
           Absyn.R_PREDEFINED_REAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_PREDEFINED_REAL()"));
      then txt;

    case ( txt,
           Absyn.R_PREDEFINED_STRING() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_PREDEFINED_STRING()"));
      then txt;

    case ( txt,
           Absyn.R_PREDEFINED_BOOLEAN() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_PREDEFINED_BOOLEAN()"));
      then txt;

    case ( txt,
           Absyn.R_PREDEFINED_ENUMERATION() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_PREDEFINED_ENUMERATION()"));
      then txt;

    case ( txt,
           Absyn.R_UNIONTYPE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_UNIONTYPE()"));
      then txt;

    case ( txt,
           Absyn.R_METARECORD(name = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MR: Does not work"));
      then txt;

    case ( txt,
           Absyn.R_UNKNOWN() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("R_UNKNOWN()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpRestriction;

protected function lm_29
  input Tpl.Text in_txt;
  input list<Absyn.ElementItem> in_items;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_options)
    local
      Tpl.Text txt;
      list<Absyn.ElementItem> rest;
      Dump.DumpOptions a_options;
      Absyn.ElementItem i_c;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_c :: rest,
           a_options )
      equation
        txt = dumpElementItem(txt, i_c, a_options);
        txt = Tpl.nextIter(txt);
        txt = lm_29(txt, rest, a_options);
      then txt;
  end match;
end lm_29;

protected function lm_30
  input Tpl.Text in_txt;
  input list<Absyn.ElementItem> in_items;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_options)
    local
      Tpl.Text txt;
      list<Absyn.ElementItem> rest;
      Dump.DumpOptions a_options;
      Absyn.ElementItem i_c;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_c :: rest,
           a_options )
      equation
        txt = dumpElementItem(txt, i_c, a_options);
        txt = Tpl.nextIter(txt);
        txt = lm_30(txt, rest, a_options);
      then txt;
  end match;
end lm_30;

protected function lm_31
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_exp;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_exp :: rest )
      equation
        txt = dumpExp(txt, i_exp);
        txt = Tpl.nextIter(txt);
        txt = lm_31(txt, rest);
      then txt;
  end match;
end lm_31;

protected function lm_32
  input Tpl.Text in_txt;
  input list<Absyn.EquationItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.EquationItem> rest;
      Absyn.EquationItem i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpEquationItem(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_32(txt, rest);
      then txt;
  end match;
end lm_32;

protected function lm_33
  input Tpl.Text in_txt;
  input list<Absyn.EquationItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.EquationItem> rest;
      Absyn.EquationItem i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpEquationItem(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_33(txt, rest);
      then txt;
  end match;
end lm_33;

protected function lm_34
  input Tpl.Text in_txt;
  input list<Absyn.AlgorithmItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> rest;
      Absyn.AlgorithmItem i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpAlgorithmItem(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_34(txt, rest);
      then txt;
  end match;
end lm_34;

protected function lm_35
  input Tpl.Text in_txt;
  input list<Absyn.AlgorithmItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> rest;
      Absyn.AlgorithmItem i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpAlgorithmItem(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_35(txt, rest);
      then txt;
  end match;
end lm_35;

protected function fun_36
  input Tpl.Text in_txt;
  input Option<Absyn.Annotation> in_a_annotation__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_annotation__)
    local
      Tpl.Text txt;
      Absyn.Annotation i_ann;

    case ( txt,
           SOME(i_ann) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpAnnotation(txt, i_ann);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_36;

protected function fun_37
  input Tpl.Text in_txt;
  input Option<Absyn.Ident> in_a_funcName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_funcName)
    local
      Tpl.Text txt;
      Absyn.Ident i_fn;

    case ( txt,
           SOME(i_fn) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = Tpl.writeStr(txt, i_fn);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_37;

protected function fun_38
  input Tpl.Text in_txt;
  input Option<String> in_a_lang;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_lang)
    local
      Tpl.Text txt;

    case ( txt,
           SOME(_) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME(1)"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_38;

protected function fun_39
  input Tpl.Text in_txt;
  input Option<Absyn.ComponentRef> in_a_output__;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_output__)
    local
      Tpl.Text txt;
      Absyn.ComponentRef i_o;

    case ( txt,
           SOME(i_o) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpCref(txt, i_o);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_39;

protected function lm_40
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_arg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_arg :: rest )
      equation
        txt = dumpExp(txt, i_arg);
        txt = Tpl.nextIter(txt);
        txt = lm_40(txt, rest);
      then txt;
  end match;
end lm_40;

protected function fun_41
  input Tpl.Text in_txt;
  input Absyn.ExternalDecl in_a_externalDecl;
  input Tpl.Text in_a_ann__str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_externalDecl, in_a_ann__str)
    local
      Tpl.Text txt;
      Tpl.Text a_ann__str;
      Option<Absyn.Annotation> i_annotation__;
      list<Absyn.Exp> i_args;
      Option<Absyn.ComponentRef> i_output__;
      Option<String> i_lang;
      Option<Absyn.Ident> i_funcName;
      Tpl.Text l_ann2__str;
      Tpl.Text l_args__str;
      Tpl.Text l_output__str;
      Tpl.Text l_lang__str;
      Tpl.Text l_fn__str;

    case ( txt,
           Absyn.EXTERNALDECL(funcName = i_funcName, lang = i_lang, output_ = i_output__, args = i_args, annotation_ = i_annotation__),
           a_ann__str )
      equation
        l_fn__str = fun_37(Tpl.emptyTxt, i_funcName);
        l_lang__str = fun_38(Tpl.emptyTxt, i_lang);
        l_output__str = fun_39(Tpl.emptyTxt, i_output__);
        l_args__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_args__str = lm_40(l_args__str, i_args);
        l_args__str = Tpl.popIter(l_args__str);
        l_ann2__str = dumpAnnotationOptSpace(Tpl.emptyTxt, i_annotation__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EXTERNAL(EXTERNALDECL("));
        txt = Tpl.writeText(txt, l_fn__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_lang__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_output__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_ann2__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, a_ann__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end fun_41;

public function dumpClassPart
  input Tpl.Text in_txt;
  input Absyn.ClassPart in_a_class__part;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_class__part, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      Absyn.ExternalDecl i_externalDecl;
      Option<Absyn.Annotation> i_annotation__;
      list<Absyn.AlgorithmItem> i_contents_3;
      list<Absyn.EquationItem> i_contents_2;
      list<Absyn.Exp> i_contents_1;
      list<Absyn.ElementItem> i_contents;
      Tpl.Text l_ann__str;
      Tpl.Text l_el__str;

    case ( txt,
           Absyn.PUBLIC(contents = i_contents),
           a_options )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_29(l_el__str, i_contents, a_options);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PUBLIC(list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.PROTECTED(contents = i_contents),
           a_options )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_30(l_el__str, i_contents, a_options);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PROTECTED(list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.CONSTRAINTS(contents = i_contents_1),
           _ )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_31(l_el__str, i_contents_1);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONSTRAINTS("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EQUATIONS(contents = i_contents_2),
           _ )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_32(l_el__str, i_contents_2);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQUATIONS(list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.INITIALEQUATIONS(contents = i_contents_2),
           _ )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_33(l_el__str, i_contents_2);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INITIALEQUATIONS(list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.ALGORITHMS(contents = i_contents_3),
           _ )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_34(l_el__str, i_contents_3);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALGORITHMS(list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.INITIALALGORITHMS(contents = i_contents_3),
           _ )
      equation
        l_el__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_el__str = lm_35(l_el__str, i_contents_3);
        l_el__str = Tpl.popIter(l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INITIALALGORITHMS(list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.EXTERNAL(annotation_ = i_annotation__, externalDecl = i_externalDecl),
           _ )
      equation
        l_ann__str = fun_36(Tpl.emptyTxt, i_annotation__);
        txt = fun_41(txt, i_externalDecl, l_ann__str);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dumpClassPart;

public function dumpWithin
  input Tpl.Text in_txt;
  input Absyn.Within in_a_within;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_within)
    local
      Tpl.Text txt;
      Absyn.Path i_path;

    case ( txt,
           Absyn.TOP() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TOP()"));
      then txt;

    case ( txt,
           Absyn.WITHIN(path = i_path) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("WITHIN("));
        txt = dumpPath(txt, i_path);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpWithin;

protected function fun_44
  input Tpl.Text in_txt;
  input Boolean in_a_isReadOnly;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_isReadOnly)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end fun_44;

public function dumpInfo
  input Tpl.Text in_txt;
  input SourceInfo in_a_info;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_info)
    local
      Tpl.Text txt;
      Integer i_columnNumberEnd;
      Integer i_lineNumberEnd;
      Integer i_columnNumberStart;
      Integer i_lineNumberStart;
      String i_fileName;
      Boolean i_isReadOnly;
      Tpl.Text l_rm__str;

    case ( txt,
           SOURCEINFO(isReadOnly = i_isReadOnly, fileName = i_fileName, lineNumberStart = i_lineNumberStart, columnNumberStart = i_columnNumberStart, lineNumberEnd = i_lineNumberEnd, columnNumberEnd = i_columnNumberEnd) )
      equation
        l_rm__str = fun_44(Tpl.emptyTxt, i_isReadOnly);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOURCEINFO(\""));
        txt = Tpl.writeStr(txt, i_fileName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = Tpl.writeText(txt, l_rm__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_lineNumberStart));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_columnNumberStart));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_lineNumberEnd));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeStr(txt, intString(i_columnNumberEnd));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpInfo;

protected function lm_46
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> rest;
      Absyn.ElementArg i_earg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_earg :: rest )
      equation
        txt = dumpElementArg(txt, i_earg);
        txt = Tpl.nextIter(txt);
        txt = lm_46(txt, rest);
      then txt;
  end match;
end lm_46;

public function dumpAnnotation
  input Tpl.Text in_txt;
  input Absyn.Annotation in_a_ann;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ann)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> i_elementArgs;

    case ( txt,
           Absyn.ANNOTATION(elementArgs = {}) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ANNOTATION(list())"));
      then txt;

    case ( txt,
           Absyn.ANNOTATION(elementArgs = i_elementArgs) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ANNOTATION(list("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_46(txt, i_elementArgs);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpAnnotation;

public function dumpAnnotationOpt
  input Tpl.Text in_txt;
  input Option<Absyn.Annotation> in_a_oann;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_oann)
    local
      Tpl.Text txt;
      Absyn.Annotation i_ann;

    case ( txt,
           SOME(i_ann) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpAnnotation(txt, i_ann);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end dumpAnnotationOpt;

public function dumpAnnotationOptSpace
  input Tpl.Text in_txt;
  input Option<Absyn.Annotation> in_a_oann;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_oann)
    local
      Tpl.Text txt;

    case ( txt,
           SOME(_) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME(dumpAnnotation(ann))"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end dumpAnnotationOptSpace;

public function dumpComment
  input Tpl.Text in_txt;
  input Absyn.Comment in_a_cmt;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cmt)
    local
      Tpl.Text txt;
      Option<Absyn.Annotation> i_annotation__;
      Option<String> i_comment;

    case ( txt,
           Absyn.COMMENT(comment = i_comment, annotation_ = i_annotation__) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("COMMENT("));
        txt = dumpStringCommentOption(txt, i_comment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpAnnotationOptSpace(txt, i_annotation__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpComment;

public function dumpCommentOpt
  input Tpl.Text in_txt;
  input Option<Absyn.Comment> in_a_ocmt;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ocmt)
    local
      Tpl.Text txt;
      Absyn.Comment i_cmt;

    case ( txt,
           SOME(i_cmt) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpComment(txt, i_cmt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end dumpCommentOpt;

protected function fun_52
  input Tpl.Text in_txt;
  input Option<Absyn.Modification> in_a_modification;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_modification)
    local
      Tpl.Text txt;
      Absyn.Modification i_mod;

    case ( txt,
           SOME(i_mod) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpModification(txt, i_mod);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_52;

protected function fun_53
  input Tpl.Text in_txt;
  input Option<Absyn.ConstrainClass> in_a_constrainClass;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_constrainClass)
    local
      Tpl.Text txt;
      Absyn.ConstrainClass i_cc;

    case ( txt,
           SOME(i_cc) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpConstrainClass(txt, i_cc);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_53;

public function dumpElementArg
  input Tpl.Text in_txt;
  input Absyn.ElementArg in_a_earg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_earg)
    local
      Tpl.Text txt;
      Option<Absyn.ConstrainClass> i_constrainClass;
      Absyn.ElementSpec i_elementSpec;
      Absyn.RedeclareKeywords i_redeclareKeywords;
      SourceInfo i_info;
      Option<String> i_comment;
      Option<Absyn.Modification> i_modification;
      Absyn.Path i_path;
      Boolean i_finalPrefix;
      Absyn.Each i_eachPrefix;
      Tpl.Text l_cc__str;
      Tpl.Text l_elem__str;
      Tpl.Text l_redecl__str;
      Tpl.Text l_info__str;
      Tpl.Text l_cmt__str;
      Tpl.Text l_mod__str;
      Tpl.Text l_path__str;
      Tpl.Text l_final__str;
      Tpl.Text l_each__str;

    case ( txt,
           Absyn.MODIFICATION(eachPrefix = i_eachPrefix, finalPrefix = i_finalPrefix, path = i_path, modification = i_modification, comment = i_comment, info = i_info) )
      equation
        l_each__str = dumpEach(Tpl.emptyTxt, i_eachPrefix);
        l_final__str = dumpFinal(Tpl.emptyTxt, i_finalPrefix);
        l_path__str = dumpPath(Tpl.emptyTxt, i_path);
        l_mod__str = fun_52(Tpl.emptyTxt, i_modification);
        l_cmt__str = dumpStringCommentOption(Tpl.emptyTxt, i_comment);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MODIFICATION("));
        txt = Tpl.writeText(txt, l_final__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_each__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_path__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_mod__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.REDECLARATION(eachPrefix = i_eachPrefix, finalPrefix = i_finalPrefix, redeclareKeywords = i_redeclareKeywords, elementSpec = i_elementSpec, constrainClass = i_constrainClass, info = i_info) )
      equation
        l_each__str = dumpEach(Tpl.emptyTxt, i_eachPrefix);
        l_final__str = dumpFinal(Tpl.emptyTxt, i_finalPrefix);
        l_redecl__str = dumpRedeclare(Tpl.emptyTxt, i_redeclareKeywords);
        l_elem__str = dumpElementSpec(Tpl.emptyTxt, i_elementSpec, Tpl.textString(l_final__str), "", "", "", Dump.defaultDumpOptions);
        l_cc__str = fun_53(Tpl.emptyTxt, i_constrainClass);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REDECLARATION("));
        txt = Tpl.writeText(txt, l_final__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_redecl__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_each__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_elem__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cc__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpElementArg;

public function dumpEach
  input Tpl.Text in_txt;
  input Absyn.Each in_a_each;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_each)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.EACH() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EACH()"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NON_EACH()"));
      then txt;
  end match;
end dumpEach;

public function dumpFinal
  input Tpl.Text in_txt;
  input Boolean in_a_final;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_final)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end dumpFinal;

public function dumpRedeclare
  input Tpl.Text in_txt;
  input Absyn.RedeclareKeywords in_a_redecl;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_redecl)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.REDECLARE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REDECLARE()"));
      then txt;

    case ( txt,
           Absyn.REDECLARE_REPLACEABLE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REDECLARE_REPLACEABLE()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpRedeclare;

public function dumpReplaceable
  input Tpl.Text in_txt;
  input Absyn.RedeclareKeywords in_a_repl;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_repl)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.REPLACEABLE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REPLACEABLE()"));
      then txt;

    case ( txt,
           Absyn.REDECLARE_REPLACEABLE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REDECLARE_REPLACEABLE()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpReplaceable;

public function dumpInnerOuter
  input Tpl.Text in_txt;
  input Absyn.InnerOuter in_a_io;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_io)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.INNER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INNER()"));
      then txt;

    case ( txt,
           Absyn.OUTER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OUTER()"));
      then txt;

    case ( txt,
           Absyn.INNER_OUTER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INNER_OUTER()"));
      then txt;

    case ( txt,
           Absyn.NOT_INNER_OUTER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT_INNER_OUTER()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpInnerOuter;

protected function lm_60
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> rest;
      Absyn.ElementArg i_earg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_earg :: rest )
      equation
        txt = dumpElementArg(txt, i_earg);
        txt = Tpl.nextIter(txt);
        txt = lm_60(txt, rest);
      then txt;
  end match;
end lm_60;

public function dumpModification
  input Tpl.Text in_txt;
  input Absyn.Modification in_a_mod;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_mod)
    local
      Tpl.Text txt;
      Absyn.EqMod i_eqMod;
      list<Absyn.ElementArg> i_elementArgLst;
      Tpl.Text l_eq__str;
      Tpl.Text l_arg__str;

    case ( txt,
           Absyn.CLASSMOD(elementArgLst = i_elementArgLst, eqMod = i_eqMod) )
      equation
        l_arg__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_arg__str = lm_60(l_arg__str, i_elementArgLst);
        l_arg__str = Tpl.popIter(l_arg__str);
        l_eq__str = dumpEqMod(Tpl.emptyTxt, i_eqMod);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CLASSMOD(list("));
        txt = Tpl.writeText(txt, l_arg__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_eq__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpModification;

public function dumpEqMod
  input Tpl.Text in_txt;
  input Absyn.EqMod in_a_eqmod;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_eqmod)
    local
      Tpl.Text txt;
      SourceInfo i_info;
      Absyn.Exp i_exp;
      Tpl.Text l_info__str;
      Tpl.Text l_exp__str;

    case ( txt,
           Absyn.EQMOD(exp = i_exp, info = i_info) )
      equation
        l_exp__str = dumpExp(Tpl.emptyTxt, i_exp);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQMOD("));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.NOMOD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOMOD()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpEqMod;

protected function lm_63
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> rest;
      Absyn.ElementArg i_earg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_earg :: rest )
      equation
        txt = dumpElementArg(txt, i_earg);
        txt = Tpl.nextIter(txt);
        txt = lm_63(txt, rest);
      then txt;
  end match;
end lm_63;

protected function lm_64
  input Tpl.Text in_txt;
  input list<Absyn.ComponentItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ComponentItem> rest;
      Absyn.ComponentItem i_comp;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_comp :: rest )
      equation
        txt = dumpComponentItem(txt, i_comp);
        txt = Tpl.nextIter(txt);
        txt = lm_64(txt, rest);
      then txt;
  end match;
end lm_64;

protected function fun_65
  input Tpl.Text in_txt;
  input Absyn.ElementSpec in_a_elem;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_elem, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      Absyn.Import i_import__;
      SourceInfo i_info;
      Option<Absyn.Comment> i_comment;
      list<Absyn.ComponentItem> i_components;
      Absyn.ElementAttributes i_attributes;
      Absyn.TypeSpec i_typeSpec;
      Option<Absyn.Annotation> i_annotationOpt;
      list<Absyn.ElementArg> i_elementArg;
      Absyn.Path i_path;
      Absyn.Class i_class__;
      Boolean i_replaceable__;
      Tpl.Text l_info__str;
      Tpl.Text l_cmt__str;
      Tpl.Text l_comps__str;
      Tpl.Text l_attr__str;
      Tpl.Text l_ty__str;
      Tpl.Text l_ann__str;
      Tpl.Text l_args__str;
      Tpl.Text l_bc__str;

    case ( txt,
           Absyn.CLASSDEF(replaceable_ = i_replaceable__, class_ = i_class__),
           a_options )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CLASSDEF("));
        txt = Tpl.writeStr(txt, Tpl.booleanString(i_replaceable__));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpClass(txt, i_class__, a_options);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EXTENDS(path = i_path, elementArg = i_elementArg, annotationOpt = i_annotationOpt),
           _ )
      equation
        l_bc__str = dumpPath(Tpl.emptyTxt, i_path);
        l_args__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_args__str = lm_63(l_args__str, i_elementArg);
        l_args__str = Tpl.popIter(l_args__str);
        l_ann__str = dumpAnnotationOptSpace(Tpl.emptyTxt, i_annotationOpt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EXTENDS("));
        txt = Tpl.writeText(txt, l_bc__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_ann__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.COMPONENTS(typeSpec = i_typeSpec, attributes = i_attributes, components = i_components),
           _ )
      equation
        l_ty__str = dumpTypeSpec(Tpl.emptyTxt, i_typeSpec);
        l_attr__str = dumpElementAttr(Tpl.emptyTxt, i_attributes);
        l_comps__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_comps__str = lm_64(l_comps__str, i_components);
        l_comps__str = Tpl.popIter(l_comps__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("COMPONENTS("));
        txt = Tpl.writeText(txt, l_attr__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_comps__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.IMPORT(comment = i_comment, info = i_info, import_ = i_import__),
           _ )
      equation
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("IMPORT("));
        txt = dumpImport(txt, i_import__);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end fun_65;

public function dumpElementSpec
  input Tpl.Text txt;
  input Absyn.ElementSpec a_elem;
  input String a_final;
  input String a_redecl;
  input String a_repl;
  input String a_io;
  input Dump.DumpOptions a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_65(txt, a_elem, a_options);
end dumpElementSpec;

protected function fun_67
  input Tpl.Text in_txt;
  input Boolean in_a_flowPrefix;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_flowPrefix)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end fun_67;

protected function fun_68
  input Tpl.Text in_txt;
  input Boolean in_a_streamPrefix;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_streamPrefix)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end fun_68;

public function dumpElementAttr
  input Tpl.Text in_txt;
  input Absyn.ElementAttributes in_a_attr;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_attr)
    local
      Tpl.Text txt;
      Absyn.ArrayDim i_arrayDim;
      Absyn.Direction i_direction;
      Absyn.Variability i_variability;
      Absyn.IsField i_isField;
      Absyn.Parallelism i_parallelism;
      Boolean i_streamPrefix;
      Boolean i_flowPrefix;
      Tpl.Text l_array__dim;
      Tpl.Text l_dir__str;
      Tpl.Text l_var__str;
      Tpl.Text l_field__str;
      Tpl.Text l_par__str;
      Tpl.Text l_stream__str;
      Tpl.Text l_flow__str;

    case ( txt,
           Absyn.ATTR(flowPrefix = i_flowPrefix, streamPrefix = i_streamPrefix, parallelism = i_parallelism, isField = i_isField, variability = i_variability, direction = i_direction, arrayDim = i_arrayDim) )
      equation
        l_flow__str = fun_67(Tpl.emptyTxt, i_flowPrefix);
        l_stream__str = fun_68(Tpl.emptyTxt, i_streamPrefix);
        l_par__str = dumpParallelism(Tpl.emptyTxt, i_parallelism);
        l_field__str = dumpIsField(Tpl.emptyTxt, i_isField);
        l_var__str = dumpVariability(Tpl.emptyTxt, i_variability);
        l_dir__str = dumpDirection(Tpl.emptyTxt, i_direction);
        l_array__dim = dumpArrayDim(Tpl.emptyTxt, i_arrayDim);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ATTR("));
        txt = Tpl.writeText(txt, l_flow__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_stream__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_par__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_var__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_dir__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_field__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_array__dim);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpElementAttr;

public function dumpParallelism
  input Tpl.Text in_txt;
  input Absyn.Parallelism in_a_par;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_par)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.PARGLOBAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PARGLOBAL()"));
      then txt;

    case ( txt,
           Absyn.PARLOCAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PARGLOBAL()"));
      then txt;

    case ( txt,
           Absyn.NON_PARALLEL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NON_PARALLEL()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpParallelism;

public function dumpIsField
  input Tpl.Text in_txt;
  input Absyn.IsField in_a_isField;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_isField)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.NONFIELD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONFIELD()"));
      then txt;

    case ( txt,
           Absyn.FIELD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FIELD()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpIsField;

public function dumpVariability
  input Tpl.Text in_txt;
  input Absyn.Variability in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.VAR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("VAR()"));
      then txt;

    case ( txt,
           Absyn.DISCRETE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("DISCRETE()"));
      then txt;

    case ( txt,
           Absyn.PARAM() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PARAM()"));
      then txt;

    case ( txt,
           Absyn.CONST() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONST()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpVariability;

public function dumpDirection
  input Tpl.Text in_txt;
  input Absyn.Direction in_a_dir;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_dir)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.BIDIR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BIDIR()"));
      then txt;

    case ( txt,
           Absyn.INPUT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INPUT()"));
      then txt;

    case ( txt,
           Absyn.OUTPUT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OUTPUT()"));
      then txt;

    case ( txt,
           Absyn.INPUT_OUTPUT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INPUT_OUTPUT()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpDirection;

public function dumpElementAttrDim
  input Tpl.Text in_txt;
  input Absyn.ElementAttributes in_a_attr;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_attr)
    local
      Tpl.Text txt;
      Absyn.ArrayDim i_arrayDim;

    case ( txt,
           Absyn.ATTR(arrayDim = i_arrayDim) )
      equation
        txt = dumpSubscripts(txt, i_arrayDim);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpElementAttrDim;

protected function lm_75
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> rest;
      Absyn.ElementArg i_e;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_e :: rest )
      equation
        txt = dumpElementArg(txt, i_e);
        txt = Tpl.nextIter(txt);
        txt = lm_75(txt, rest);
      then txt;
  end match;
end lm_75;

protected function fun_76
  input Tpl.Text in_txt;
  input list<Absyn.ElementArg> in_a_el;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_el)
    local
      Tpl.Text txt;
      list<Absyn.ElementArg> i_el;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_el )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_75(txt, i_el);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end fun_76;

public function dumpConstrainClass
  input Tpl.Text in_txt;
  input Absyn.ConstrainClass in_a_cc;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cc)
    local
      Tpl.Text txt;
      Option<Absyn.Comment> i_comment;
      list<Absyn.ElementArg> i_el;
      Absyn.Path i_p;
      Tpl.Text l_cmt__str;
      Tpl.Text l_el__str;
      Tpl.Text l_path__str;

    case ( txt,
           Absyn.CONSTRAINCLASS(elementSpec = Absyn.EXTENDS(path = i_p, elementArg = i_el), comment = i_comment) )
      equation
        l_path__str = dumpPath(Tpl.emptyTxt, i_p);
        l_el__str = fun_76(Tpl.emptyTxt, i_el);
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONSTRAINCLASS("));
        txt = Tpl.writeText(txt, l_path__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_el__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpConstrainClass;

public function dumpComponentItem
  input Tpl.Text in_txt;
  input Absyn.ComponentItem in_a_comp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_comp)
    local
      Tpl.Text txt;
      Option<Absyn.Comment> i_comment;
      Option<Absyn.ComponentCondition> i_condition;
      Absyn.Component i_component;
      Tpl.Text l_cmt;
      Tpl.Text l_cond__str;
      Tpl.Text l_comp__str;

    case ( txt,
           Absyn.COMPONENTITEM(component = i_component, condition = i_condition, comment = i_comment) )
      equation
        l_comp__str = dumpComponent(Tpl.emptyTxt, i_component);
        l_cond__str = dumpComponentCondition(Tpl.emptyTxt, i_condition);
        l_cmt = dumpCommentOpt(Tpl.emptyTxt, i_comment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("COMPONENTITEM("));
        txt = Tpl.writeText(txt, l_comp__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cond__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpComponentItem;

protected function fun_79
  input Tpl.Text in_txt;
  input Option<Absyn.Modification> in_a_modification;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_modification)
    local
      Tpl.Text txt;
      Absyn.Modification i_mod;

    case ( txt,
           SOME(i_mod) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpModification(txt, i_mod);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_79;

public function dumpComponent
  input Tpl.Text in_txt;
  input Absyn.Component in_a_comp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_comp)
    local
      Tpl.Text txt;
      Absyn.Ident i_name;
      Option<Absyn.Modification> i_modification;
      Absyn.ArrayDim i_arrayDim;
      String ret_2;
      Tpl.Text l_mod__str;
      Tpl.Text l_dim__str;

    case ( txt,
           Absyn.COMPONENT(arrayDim = i_arrayDim, modification = i_modification, name = i_name) )
      equation
        l_dim__str = dumpSubscripts(Tpl.emptyTxt, i_arrayDim);
        l_mod__str = fun_79(Tpl.emptyTxt, i_modification);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("COMPONENT(\""));
        ret_2 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = Tpl.writeText(txt, l_dim__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_mod__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpComponent;

public function dumpComponentCondition
  input Tpl.Text in_txt;
  input Option<Absyn.ComponentCondition> in_a_cond;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cond)
    local
      Tpl.Text txt;
      Absyn.ComponentCondition i_cexp;

    case ( txt,
           SOME(i_cexp) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpExp(txt, i_cexp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end dumpComponentCondition;

protected function lm_82
  input Tpl.Text in_txt;
  input list<Absyn.GroupImport> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.GroupImport> rest;
      Absyn.GroupImport i_group;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_group :: rest )
      equation
        txt = dumpGroupImport(txt, i_group);
        txt = Tpl.nextIter(txt);
        txt = lm_82(txt, rest);
      then txt;
  end match;
end lm_82;

public function dumpImport
  input Tpl.Text in_txt;
  input Absyn.Import in_a_imp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_imp)
    local
      Tpl.Text txt;
      list<Absyn.GroupImport> i_groups;
      Absyn.Path i_prefix;
      Absyn.Path i_path;
      Absyn.Ident i_name;
      Tpl.Text l_groups__str;
      Tpl.Text l_prefix__str;
      String ret_0;

    case ( txt,
           Absyn.NAMED_IMPORT(name = i_name, path = i_path) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NAMED_IMPORT(\""));
        ret_0 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = dumpPath(txt, i_path);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.QUAL_IMPORT(path = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("QUAL_IMPORT(dumpPath(path))"));
      then txt;

    case ( txt,
           Absyn.UNQUAL_IMPORT(path = i_path) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNQUAL_IMPORT("));
        txt = dumpPath(txt, i_path);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.GROUP_IMPORT(prefix = i_prefix, groups = i_groups) )
      equation
        l_prefix__str = dumpPath(Tpl.emptyTxt, i_prefix);
        l_groups__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(",")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_groups__str = lm_82(l_groups__str, i_groups);
        l_groups__str = Tpl.popIter(l_groups__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GROUP_IMPORT("));
        txt = Tpl.writeText(txt, l_prefix__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_groups__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpImport;

public function dumpGroupImport
  input Tpl.Text in_txt;
  input Absyn.GroupImport in_a_gimp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_gimp)
    local
      Tpl.Text txt;
      String i_rename;
      String i_name;
      String ret_2;
      String ret_1;
      String ret_0;

    case ( txt,
           Absyn.GROUP_IMPORT_NAME(name = i_name) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GROUP_IMPORT_NAME(\""));
        ret_0 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           Absyn.GROUP_IMPORT_RENAME(rename = i_rename, name = i_name) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GROUP_IMPORT_RENAME(\""));
        ret_1 = Util.escapeModelicaStringToCString(i_rename);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", \""));
        ret_2 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpGroupImport;

public function dumpElementItem
  input Tpl.Text in_txt;
  input Absyn.ElementItem in_a_eitem;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_eitem, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      String i_comment;
      Absyn.Element i_element;
      String ret_0;

    case ( txt,
           Absyn.ELEMENTITEM(element = i_element),
           a_options )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ELEMENTITEM("));
        txt = dumpElement(txt, i_element, a_options);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.LEXER_COMMENT(comment = i_comment),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LEXER_COMMENT(\""));
        ret_0 = System.trimWhitespace(i_comment);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dumpElementItem;

protected function fun_86
  input Tpl.Text in_txt;
  input Option<Absyn.RedeclareKeywords> in_a_redeclareKeywords;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_redeclareKeywords)
    local
      Tpl.Text txt;
      Absyn.RedeclareKeywords i_re;

    case ( txt,
           SOME(i_re) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpRedeclare(txt, i_re);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_86;

protected function fun_87
  input Tpl.Text in_txt;
  input Option<Absyn.RedeclareKeywords> in_a_redeclareKeywords;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_redeclareKeywords)
    local
      Tpl.Text txt;
      Absyn.RedeclareKeywords i_re;

    case ( txt,
           SOME(i_re) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpReplaceable(txt, i_re);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_87;

protected function fun_88
  input Tpl.Text in_txt;
  input Option<Absyn.ConstrainClass> in_a_constrainClass;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_constrainClass)
    local
      Tpl.Text txt;
      Absyn.ConstrainClass i_cc;

    case ( txt,
           SOME(i_cc) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpConstrainClass(txt, i_cc);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_88;

protected function fun_89
  input Tpl.Text in_txt;
  input Boolean in_mArg;
  input SourceInfo in_a_info;
  input Option<Absyn.ConstrainClass> in_a_constrainClass;
  input Dump.DumpOptions in_a_options;
  input Absyn.ElementSpec in_a_specification;
  input Absyn.InnerOuter in_a_innerOuter;
  input Option<Absyn.RedeclareKeywords> in_a_redeclareKeywords;
  input Boolean in_a_finalPrefix;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_mArg, in_a_info, in_a_constrainClass, in_a_options, in_a_specification, in_a_innerOuter, in_a_redeclareKeywords, in_a_finalPrefix)
    local
      Tpl.Text txt;
      SourceInfo a_info;
      Option<Absyn.ConstrainClass> a_constrainClass;
      Dump.DumpOptions a_options;
      Absyn.ElementSpec a_specification;
      Absyn.InnerOuter a_innerOuter;
      Option<Absyn.RedeclareKeywords> a_redeclareKeywords;
      Boolean a_finalPrefix;
      Tpl.Text l_info__str;
      Tpl.Text l_cc__str;
      Tpl.Text l_ec__str;
      Tpl.Text l_io__str;
      Tpl.Text l_repl__str;
      Tpl.Text l_redecl__str;
      Tpl.Text l_final__str;

    case ( txt,
           false,
           _,
           _,
           _,
           _,
           _,
           _,
           _ )
      then txt;

    case ( txt,
           _,
           a_info,
           a_constrainClass,
           a_options,
           a_specification,
           a_innerOuter,
           a_redeclareKeywords,
           a_finalPrefix )
      equation
        l_final__str = dumpFinal(Tpl.emptyTxt, a_finalPrefix);
        l_redecl__str = fun_86(Tpl.emptyTxt, a_redeclareKeywords);
        l_repl__str = fun_87(Tpl.emptyTxt, a_redeclareKeywords);
        l_io__str = dumpInnerOuter(Tpl.emptyTxt, a_innerOuter);
        l_ec__str = dumpElementSpec(Tpl.emptyTxt, a_specification, Tpl.textString(l_final__str), Tpl.textString(l_redecl__str), Tpl.textString(l_repl__str), Tpl.textString(l_io__str), a_options);
        l_cc__str = fun_88(Tpl.emptyTxt, a_constrainClass);
        l_info__str = dumpInfo(Tpl.emptyTxt, a_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ELEMENT("));
        txt = Tpl.writeStr(txt, Tpl.booleanString(a_finalPrefix));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_redecl__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_io__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_ec__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cc__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end fun_89;

protected function lm_90
  input Tpl.Text in_txt;
  input list<Absyn.NamedArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.NamedArg> rest;
      Absyn.NamedArg i_arg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_arg :: rest )
      equation
        txt = dumpNamedArg(txt, i_arg);
        txt = lm_90(txt, rest);
      then txt;
  end match;
end lm_90;

protected function fun_91
  input Tpl.Text in_txt;
  input list<Absyn.NamedArg> in_a_args;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_args)
    local
      Tpl.Text txt;
      list<Absyn.NamedArg> i_args;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_args )
      equation
        txt = lm_90(txt, i_args);
      then txt;
  end match;
end fun_91;

protected function fun_92
  input Tpl.Text in_txt;
  input Option<Absyn.Ident> in_a_optName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_optName)
    local
      Tpl.Text txt;

    case ( txt,
           SOME(_) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME(name)"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_92;

protected function fun_93
  input Tpl.Text in_txt;
  input Boolean in_mArg;
  input String in_a_string;
  input SourceInfo in_a_info;
  input Option<Absyn.Ident> in_a_optName;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_mArg, in_a_string, in_a_info, in_a_optName)
    local
      Tpl.Text txt;
      String a_string;
      SourceInfo a_info;
      Option<Absyn.Ident> a_optName;
      Tpl.Text l_string__str;
      Tpl.Text l_info__str;
      Tpl.Text l_name__str;

    case ( txt,
           false,
           _,
           _,
           _ )
      then txt;

    case ( txt,
           _,
           a_string,
           a_info,
           a_optName )
      equation
        l_name__str = fun_92(Tpl.emptyTxt, a_optName);
        l_info__str = dumpInfo(Tpl.emptyTxt, a_info);
        l_string__str = Tpl.writeStr(Tpl.emptyTxt, a_string);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TEXT(\""));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\",\""));
        txt = Tpl.writeText(txt, l_string__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\","));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end fun_93;

public function dumpElement
  input Tpl.Text in_txt;
  input Absyn.Element in_a_elem;
  input Dump.DumpOptions in_a_options;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_elem, in_a_options)
    local
      Tpl.Text txt;
      Dump.DumpOptions a_options;
      String i_string;
      Option<Absyn.Ident> i_optName;
      Absyn.Ident i_name;
      list<Absyn.NamedArg> i_args;
      Option<Absyn.ConstrainClass> i_constrainClass;
      Absyn.ElementSpec i_specification;
      Absyn.InnerOuter i_innerOuter;
      Option<Absyn.RedeclareKeywords> i_redeclareKeywords;
      Boolean i_finalPrefix;
      Absyn.Element i_elem;
      SourceInfo i_info;
      Boolean ret_6;
      String ret_5;
      Tpl.Text l_args__str;
      Boolean ret_3;
      Boolean ret_2;
      Boolean ret_1;
      Boolean ret_0;

    case ( txt,
           (i_elem as Absyn.ELEMENT(info = i_info, finalPrefix = i_finalPrefix, redeclareKeywords = i_redeclareKeywords, innerOuter = i_innerOuter, specification = i_specification, constrainClass = i_constrainClass)),
           a_options )
      equation
        ret_0 = Dump.boolUnparseFileFromInfo(i_info, a_options);
        ret_1 = AbsynUtil.isClassdef(i_elem);
        ret_2 = boolNot(ret_1);
        ret_3 = boolOr(ret_0, ret_2);
        txt = fun_89(txt, ret_3, i_info, i_constrainClass, a_options, i_specification, i_innerOuter, i_redeclareKeywords, i_finalPrefix);
      then txt;

    case ( txt,
           Absyn.DEFINEUNIT(args = i_args, name = i_name),
           _ )
      equation
        l_args__str = fun_91(Tpl.emptyTxt, i_args);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("DEFINEUNIT(\""));
        ret_5 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_5);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", list("));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.TEXT(info = i_info, optName = i_optName, string = i_string),
           a_options )
      equation
        ret_6 = Dump.boolUnparseFileFromInfo(i_info, a_options);
        txt = fun_93(txt, ret_6, i_string, i_info, i_optName);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dumpElement;

public function dumpEquationItem
  input Tpl.Text in_txt;
  input Absyn.EquationItem in_a_eq;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_eq)
    local
      Tpl.Text txt;
      String i_comment_1;
      SourceInfo i_info;
      Option<Absyn.Comment> i_comment;
      Absyn.Equation i_equation__;
      String ret_3;
      Tpl.Text l_info__str;
      Tpl.Text l_cmt__str;
      Tpl.Text l_eq__str;

    case ( txt,
           Absyn.EQUATIONITEM(equation_ = i_equation__, comment = i_comment, info = i_info) )
      equation
        l_eq__str = dumpEquation(Tpl.emptyTxt, i_equation__);
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQUATIONITEM("));
        txt = Tpl.writeText(txt, l_eq__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EQUATIONITEMCOMMENT(comment = i_comment_1) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQUATIONITEMCOMMENT(\""));
        ret_3 = System.trimWhitespace(i_comment_1);
        txt = Tpl.writeStr(txt, ret_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpEquationItem;

protected function lm_96
  input Tpl.Text in_txt;
  input list<Absyn.EquationItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.EquationItem> rest;
      Absyn.EquationItem i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpEquationItem(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_96(txt, rest);
      then txt;
  end match;
end lm_96;

public function dumpEquationItems
  input Tpl.Text txt;
  input list<Absyn.EquationItem> a_eql;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_96(out_txt, a_eql);
  out_txt := Tpl.popIter(out_txt);
end dumpEquationItems;

protected function lm_98
  input Tpl.Text in_txt;
  input list<tuple<Absyn.Exp, list<Absyn.EquationItem>>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<tuple<Absyn.Exp, list<Absyn.EquationItem>>> rest;
      list<Absyn.EquationItem> i_b;
      Absyn.Exp i_c;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_c, i_b) :: rest )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("tuple("));
        txt = dumpExp(txt, i_c);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = dumpEquationItems(txt, i_b);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
        txt = Tpl.nextIter(txt);
        txt = lm_98(txt, rest);
      then txt;
  end match;
end lm_98;

protected function lm_99
  input Tpl.Text in_txt;
  input list<tuple<Absyn.Exp, list<Absyn.EquationItem>>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<tuple<Absyn.Exp, list<Absyn.EquationItem>>> rest;
      list<Absyn.EquationItem> i_b;
      Absyn.Exp i_c;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_c, i_b) :: rest )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("tuple("));
        txt = dumpExp(txt, i_c);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = dumpEquationItems(txt, i_b);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
        txt = Tpl.nextIter(txt);
        txt = lm_99(txt, rest);
      then txt;
  end match;
end lm_99;

public function dumpEquation
  input Tpl.Text in_txt;
  input Absyn.Equation in_a_eq;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_eq)
    local
      Tpl.Text txt;
      Absyn.EquationItem i_equ;
      Absyn.FunctionArgs i_functionArgs;
      Absyn.ComponentRef i_functionName;
      list<Absyn.EquationItem> i_whenEquations;
      list<tuple<Absyn.Exp, list<Absyn.EquationItem>>> i_elseWhenEquations;
      Absyn.Exp i_whenExp;
      list<Absyn.EquationItem> i_forEquations;
      Absyn.ForIterators i_iterators;
      Absyn.ComponentRef i_connector2;
      Absyn.ComponentRef i_connector1;
      Absyn.ComponentRef i_domain;
      Absyn.Exp i_rightSide;
      Absyn.Exp i_leftSide;
      list<Absyn.EquationItem> i_equationElseItems;
      list<tuple<Absyn.Exp, list<Absyn.EquationItem>>> i_elseIfBranches;
      list<Absyn.EquationItem> i_equationTrueItems;
      Absyn.Exp i_ifExp;
      Tpl.Text l_eq__str;
      Tpl.Text l_args__str;
      Tpl.Text l_name__str;
      Tpl.Text l_when__eqs;
      Tpl.Text l_elsewhen__eqs__str;
      Tpl.Text l_when__str;
      Tpl.Text l_body__str;
      Tpl.Text l_iter__str;
      Tpl.Text l_c2__str;
      Tpl.Text l_c1__str;
      Tpl.Text l_domain__str;
      Tpl.Text l_rhs;
      Tpl.Text l_lhs;
      Tpl.Text l_else__branch__str;
      Tpl.Text l_elseif__str;
      Tpl.Text l_eq__true__str;
      Tpl.Text l_if__str;

    case ( txt,
           Absyn.EQ_IF(ifExp = i_ifExp, equationTrueItems = i_equationTrueItems, elseIfBranches = i_elseIfBranches, equationElseItems = i_equationElseItems) )
      equation
        l_if__str = dumpExp(Tpl.emptyTxt, i_ifExp);
        l_eq__true__str = dumpEquationItems(Tpl.emptyTxt, i_equationTrueItems);
        l_elseif__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_elseif__str = lm_98(l_elseif__str, i_elseIfBranches);
        l_elseif__str = Tpl.popIter(l_elseif__str);
        l_else__branch__str = dumpEquationItems(Tpl.emptyTxt, i_equationElseItems);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_IF("));
        txt = Tpl.writeText(txt, l_if__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_eq__true__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_elseif__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_else__branch__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.EQ_EQUALS(leftSide = i_leftSide, rightSide = i_rightSide) )
      equation
        l_lhs = dumpLhsExp(Tpl.emptyTxt, i_leftSide);
        l_rhs = dumpExp(Tpl.emptyTxt, i_rightSide);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_EQUALS("));
        txt = Tpl.writeText(txt, l_lhs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EQ_PDE(leftSide = i_leftSide, rightSide = i_rightSide, domain = i_domain) )
      equation
        l_lhs = dumpLhsExp(Tpl.emptyTxt, i_leftSide);
        l_rhs = dumpExp(Tpl.emptyTxt, i_rightSide);
        l_domain__str = dumpCref(Tpl.emptyTxt, i_domain);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_PDE("));
        txt = Tpl.writeText(txt, l_lhs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_domain__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EQ_CONNECT(connector1 = i_connector1, connector2 = i_connector2) )
      equation
        l_c1__str = dumpCref(Tpl.emptyTxt, i_connector1);
        l_c2__str = dumpCref(Tpl.emptyTxt, i_connector2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_CONNECT("));
        txt = Tpl.writeText(txt, l_c1__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_c2__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EQ_FOR(iterators = i_iterators, forEquations = i_forEquations) )
      equation
        l_iter__str = dumpForIterators(Tpl.emptyTxt, i_iterators);
        l_body__str = dumpEquationItems(Tpl.emptyTxt, i_forEquations);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_FOR("));
        txt = Tpl.writeText(txt, l_iter__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_body__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.EQ_WHEN_E(whenExp = i_whenExp, elseWhenEquations = i_elseWhenEquations, whenEquations = i_whenEquations) )
      equation
        l_when__str = dumpExp(Tpl.emptyTxt, i_whenExp);
        l_elsewhen__eqs__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_elsewhen__eqs__str = lm_99(l_elsewhen__eqs__str, i_elseWhenEquations);
        l_elsewhen__eqs__str = Tpl.popIter(l_elsewhen__eqs__str);
        l_when__eqs = dumpEquationItems(Tpl.emptyTxt, i_whenEquations);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_WHEN_E("));
        txt = Tpl.writeText(txt, l_when__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_when__eqs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("),list("));
        txt = Tpl.writeText(txt, l_elsewhen__eqs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.EQ_NORETCALL(functionName = i_functionName, functionArgs = i_functionArgs) )
      equation
        l_name__str = dumpCref(Tpl.emptyTxt, i_functionName);
        l_args__str = dumpFunctionArgs(Tpl.emptyTxt, i_functionArgs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_NORETCALL("));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.EQ_FAILURE(equ = i_equ) )
      equation
        l_eq__str = dumpEquationItem(Tpl.emptyTxt, i_equ);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQ_FAILURE("));
        txt = Tpl.writeText(txt, l_eq__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpEquation;

protected function lm_101
  input Tpl.Text in_txt;
  input list<Absyn.AlgorithmItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> rest;
      Absyn.AlgorithmItem i_alg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_alg :: rest )
      equation
        txt = dumpAlgorithmItem(txt, i_alg);
        txt = Tpl.nextIter(txt);
        txt = lm_101(txt, rest);
      then txt;
  end match;
end lm_101;

public function dumpAlgorithmItems
  input Tpl.Text txt;
  input list<Absyn.AlgorithmItem> a_algs;

  output Tpl.Text out_txt;
protected
  Tpl.Text l_items;
algorithm
  l_items := Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  l_items := lm_101(l_items, a_algs);
  l_items := Tpl.popIter(l_items);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("list("));
  out_txt := Tpl.writeText(out_txt, l_items);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")"));
end dumpAlgorithmItems;

public function dumpAlgorithmItem
  input Tpl.Text in_txt;
  input Absyn.AlgorithmItem in_a_alg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_alg)
    local
      Tpl.Text txt;
      SourceInfo i_info;
      Option<Absyn.Comment> i_comment;
      Absyn.Algorithm i_algorithm__;
      Tpl.Text l_info__str;
      Tpl.Text l_cmt__str;
      Tpl.Text l_alg__str;

    case ( txt,
           Absyn.ALGORITHMITEM(algorithm_ = i_algorithm__, comment = i_comment, info = i_info) )
      equation
        l_alg__str = dumpAlgorithm(Tpl.emptyTxt, i_algorithm__);
        l_cmt__str = dumpCommentOpt(Tpl.emptyTxt, i_comment);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALGORITHMITEM("));
        txt = Tpl.writeText(txt, l_alg__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALGORITHMITEMCOMMENT(comment = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALGORITHMITEMCOMMENT(\"I am useless. I am a comment\")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpAlgorithmItem;

protected function lm_104
  input Tpl.Text in_txt;
  input list<tuple<Absyn.Exp, list<Absyn.AlgorithmItem>>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<tuple<Absyn.Exp, list<Absyn.AlgorithmItem>>> rest;
      list<Absyn.AlgorithmItem> i_b;
      Absyn.Exp i_c;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_c, i_b) :: rest )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = dumpExp(txt, i_c);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = dumpAlgorithmItems(txt, i_b);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
        txt = Tpl.nextIter(txt);
        txt = lm_104(txt, rest);
      then txt;
  end match;
end lm_104;

protected function lm_105
  input Tpl.Text in_txt;
  input list<tuple<Absyn.Exp, list<Absyn.AlgorithmItem>>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<tuple<Absyn.Exp, list<Absyn.AlgorithmItem>>> rest;
      list<Absyn.AlgorithmItem> i_b;
      Absyn.Exp i_c;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_c, i_b) :: rest )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = dumpExp(txt, i_c);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = dumpAlgorithmItems(txt, i_b);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
        txt = Tpl.nextIter(txt);
        txt = lm_105(txt, rest);
      then txt;
  end match;
end lm_105;

protected function fun_106
  input Tpl.Text in_txt;
  input list<Absyn.AlgorithmItem> in_a_equ;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_equ)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> i_equ;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_equ )
      equation
        txt = dumpAlgorithmItems(txt, i_equ);
      then txt;
  end match;
end fun_106;

public function dumpAlgorithm
  input Tpl.Text in_txt;
  input Absyn.Algorithm in_a_alg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_alg)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> i_elseBody;
      list<Absyn.AlgorithmItem> i_body;
      list<Absyn.AlgorithmItem> i_equ;
      Absyn.FunctionArgs i_functionArgs;
      Absyn.ComponentRef i_functionCall;
      list<Absyn.AlgorithmItem> i_whenBody;
      list<tuple<Absyn.Exp, list<Absyn.AlgorithmItem>>> i_elseWhenAlgorithmBranch;
      list<Absyn.AlgorithmItem> i_whileBody;
      Absyn.Exp i_boolExpr;
      list<Absyn.AlgorithmItem> i_parforBody;
      list<Absyn.AlgorithmItem> i_forBody;
      Absyn.ForIterators i_iterators;
      list<Absyn.AlgorithmItem> i_elseBranch;
      list<tuple<Absyn.Exp, list<Absyn.AlgorithmItem>>> i_elseIfAlgorithmBranch;
      list<Absyn.AlgorithmItem> i_trueBranch;
      Absyn.Exp i_ifExp;
      Absyn.Exp i_value;
      Absyn.Exp i_assignComponent;
      Tpl.Text l_arg__str;
      Tpl.Text l_args__str;
      Tpl.Text l_name__str;
      Tpl.Text l_ewab;
      Tpl.Text l_body__str;
      Tpl.Text l_iter__str;
      Tpl.Text l_else__branch;
      Tpl.Text l_else__branch__str;
      Tpl.Text l_else__if__alg__branch;
      Tpl.Text l_true__branch;
      Tpl.Text l_if__str;
      Tpl.Text l_rhs__str;
      Tpl.Text l_lhs__str;

    case ( txt,
           Absyn.ALG_ASSIGN(assignComponent = i_assignComponent, value = i_value) )
      equation
        l_lhs__str = dumpLhsExp(Tpl.emptyTxt, i_assignComponent);
        l_rhs__str = dumpExp(Tpl.emptyTxt, i_value);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_ASSIGN("));
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_IF(ifExp = i_ifExp, trueBranch = i_trueBranch, elseIfAlgorithmBranch = i_elseIfAlgorithmBranch, elseBranch = i_elseBranch) )
      equation
        l_if__str = dumpExp(Tpl.emptyTxt, i_ifExp);
        l_true__branch = dumpAlgorithmItems(Tpl.emptyTxt, i_trueBranch);
        l_else__if__alg__branch = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_else__if__alg__branch = lm_104(l_else__if__alg__branch, i_elseIfAlgorithmBranch);
        l_else__if__alg__branch = Tpl.popIter(l_else__if__alg__branch);
        l_else__branch__str = dumpAlgorithmItems(Tpl.emptyTxt, i_elseBranch);
        l_else__branch = dumpAlgorithmItems(Tpl.emptyTxt, i_elseBranch);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_IF("));
        txt = Tpl.writeText(txt, l_if__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_true__branch);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_else__if__alg__branch);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_else__branch);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_FOR(iterators = i_iterators, forBody = i_forBody) )
      equation
        l_iter__str = dumpForIterators(Tpl.emptyTxt, i_iterators);
        l_body__str = dumpAlgorithmItems(Tpl.emptyTxt, i_forBody);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_FOR("));
        txt = Tpl.writeText(txt, l_iter__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_body__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_PARFOR(iterators = i_iterators, parforBody = i_parforBody) )
      equation
        l_iter__str = dumpForIterators(Tpl.emptyTxt, i_iterators);
        l_body__str = dumpAlgorithmItems(Tpl.emptyTxt, i_parforBody);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_PARFOR("));
        txt = Tpl.writeText(txt, l_iter__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_body__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_WHILE(boolExpr = i_boolExpr, whileBody = i_whileBody) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_WHILE("));
        txt = dumpExp(txt, i_boolExpr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpAlgorithmItems(txt, i_whileBody);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_WHEN_A(elseWhenAlgorithmBranch = i_elseWhenAlgorithmBranch, boolExpr = i_boolExpr, whenBody = i_whenBody) )
      equation
        l_ewab = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_ewab = lm_105(l_ewab, i_elseWhenAlgorithmBranch);
        l_ewab = Tpl.popIter(l_ewab);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_WHEN_A("));
        txt = dumpExp(txt, i_boolExpr);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpAlgorithmItems(txt, i_whenBody);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_ewab);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_NORETCALL(functionCall = i_functionCall, functionArgs = i_functionArgs) )
      equation
        l_name__str = dumpCref(Tpl.emptyTxt, i_functionCall);
        l_args__str = dumpFunctionArgs(Tpl.emptyTxt, i_functionArgs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_NORETCALL(\""));
        txt = Tpl.writeText(txt, l_name__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_RETURN() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_RETURN()"));
      then txt;

    case ( txt,
           Absyn.ALG_BREAK() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_BREAK()"));
      then txt;

    case ( txt,
           Absyn.ALG_FAILURE(equ = i_equ) )
      equation
        l_arg__str = fun_106(Tpl.emptyTxt, i_equ);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_FAILURE("));
        txt = Tpl.writeText(txt, l_arg__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_TRY(body = i_body, elseBody = i_elseBody) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_TRY("));
        txt = dumpAlgorithmItems(txt, i_body);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpAlgorithmItems(txt, i_elseBody);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALG_CONTINUE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALG_CONTINUE()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpAlgorithm;

protected function fun_108
  input Tpl.Text in_txt;
  input Boolean in_mArg;
  input Absyn.Path in_a_path;
  input Absyn.Ident in_a_name;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_mArg, in_a_path, in_a_name)
    local
      Tpl.Text txt;
      Absyn.Path a_path;
      Absyn.Ident a_name;
      String ret_1;
      String ret_0;

    case ( txt,
           false,
           _,
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("IDENT(\""));
        ret_0 = Util.escapeModelicaStringToCString(a_name);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           _,
           a_path,
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("QUALIFIED(\""));
        ret_1 = Util.escapeModelicaStringToCString(a_name);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = dumpPath(txt, a_path);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end fun_108;

public function dumpPath
  input Tpl.Text in_txt;
  input Absyn.Path in_a_path;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_path)
    local
      Tpl.Text txt;
      Absyn.Ident i_name;
      Absyn.Path i_path;
      String ret_1;
      Boolean ret_0;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FULLYQUALIFIED("));
        txt = dumpPath(txt, i_path);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      equation
        ret_0 = Flags.getConfigBool(Flags.MODELICA_OUTPUT);
        txt = fun_108(txt, ret_0, i_path, i_name);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("IDENT(\""));
        ret_1 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = errorMsg(txt, "SCodeDump.dumpPath: Unknown path.");
      then txt;
  end match;
end dumpPath;

public function dumpPathNoQual
  input Tpl.Text in_txt;
  input Absyn.Path in_a_path;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_path)
    local
      Tpl.Text txt;
      Absyn.Path i_path;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FULLYQUALIFIED("));
        txt = dumpPath(txt, i_path);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           i_path )
      equation
        txt = dumpPath(txt, i_path);
      then txt;
  end match;
end dumpPathNoQual;

public function dumpStringCommentOption
  input Tpl.Text in_txt;
  input Option<String> in_a_cmt;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cmt)
    local
      Tpl.Text txt;
      String i_str;

    case ( txt,
           SOME(i_str) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME(\""));
        txt = Tpl.writeStr(txt, i_str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end dumpStringCommentOption;

protected function lm_112
  input Tpl.Text in_txt;
  input list<Absyn.TypeSpec> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.TypeSpec> rest;
      Absyn.TypeSpec i_ty;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_ty :: rest )
      equation
        txt = dumpTypeSpec(txt, i_ty);
        txt = Tpl.nextIter(txt);
        txt = lm_112(txt, rest);
      then txt;
  end match;
end lm_112;

public function dumpTypeSpec
  input Tpl.Text in_txt;
  input Absyn.TypeSpec in_a_typeSpec;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_typeSpec)
    local
      Tpl.Text txt;
      list<Absyn.TypeSpec> i_typeSpecs;
      Option<Absyn.ArrayDim> i_arrayDim;
      Absyn.Path i_path;
      Tpl.Text l_ty__str;
      Tpl.Text l_arraydim__str;
      Tpl.Text l_path__str;

    case ( txt,
           Absyn.TPATH(path = i_path, arrayDim = i_arrayDim) )
      equation
        l_path__str = dumpPath(Tpl.emptyTxt, i_path);
        l_arraydim__str = dumpArrayDimOpt(Tpl.emptyTxt, i_arrayDim);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TPATH("));
        txt = Tpl.writeText(txt, l_path__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_arraydim__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.TCOMPLEX(path = i_path, typeSpecs = i_typeSpecs, arrayDim = i_arrayDim) )
      equation
        l_path__str = dumpPath(Tpl.emptyTxt, i_path);
        l_ty__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_ty__str = lm_112(l_ty__str, i_typeSpecs);
        l_ty__str = Tpl.popIter(l_ty__str);
        l_arraydim__str = dumpArrayDimOpt(Tpl.emptyTxt, i_arrayDim);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TCOMPLEX("));
        txt = Tpl.writeText(txt, l_path__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_arraydim__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpTypeSpec;

public function dumpArrayDimOpt
  input Tpl.Text in_txt;
  input Option<Absyn.ArrayDim> in_a_arraydim;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_arraydim)
    local
      Tpl.Text txt;
      Absyn.ArrayDim i_ad;

    case ( txt,
           SOME(i_ad) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpSubscripts(txt, i_ad);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end dumpArrayDimOpt;

public function dumpArrayDim
  input Tpl.Text txt;
  input Absyn.ArrayDim a_arraydim;

  output Tpl.Text out_txt;
algorithm
  out_txt := dumpSubscripts(txt, a_arraydim);
end dumpArrayDim;

protected function lm_116
  input Tpl.Text in_txt;
  input list<Absyn.Subscript> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Subscript> rest;
      Absyn.Subscript i_s;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_s :: rest )
      equation
        txt = dumpSubscript(txt, i_s);
        txt = Tpl.nextIter(txt);
        txt = lm_116(txt, rest);
      then txt;
  end match;
end lm_116;

public function dumpSubscripts
  input Tpl.Text txt;
  input list<Absyn.Subscript> a_subscripts;

  output Tpl.Text out_txt;
protected
  Tpl.Text l_sub__str;
algorithm
  l_sub__str := Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  l_sub__str := lm_116(l_sub__str, a_subscripts);
  l_sub__str := Tpl.popIter(l_sub__str);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("list("));
  out_txt := Tpl.writeText(out_txt, l_sub__str);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")"));
end dumpSubscripts;

public function dumpSubscript
  input Tpl.Text in_txt;
  input Absyn.Subscript in_a_subscript;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_subscript)
    local
      Tpl.Text txt;
      Absyn.Exp i_subscript;

    case ( txt,
           Absyn.NOSUB() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOSUB()"));
      then txt;

    case ( txt,
           Absyn.SUBSCRIPT(subscript = i_subscript) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SUBSCRIPT("));
        txt = dumpExp(txt, i_subscript);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpSubscript;

protected function lm_119
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_e;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_e :: rest )
      equation
        txt = dumpExp(txt, i_e);
        txt = Tpl.nextIter(txt);
        txt = lm_119(txt, rest);
      then txt;
  end match;
end lm_119;

protected function lm_120
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_e;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_e :: rest )
      equation
        txt = dumpExp(txt, i_e);
        txt = Tpl.nextIter(txt);
        txt = lm_120(txt, rest);
      then txt;
  end match;
end lm_120;

protected function lm_121
  input Tpl.Text in_txt;
  input list<list<Absyn.Exp>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<list<Absyn.Exp>> rest;
      list<Absyn.Exp> i_row;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_row :: rest )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("list("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_120(txt, i_row);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        txt = Tpl.nextIter(txt);
        txt = lm_121(txt, rest);
      then txt;
  end match;
end lm_121;

protected function lm_122
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_e;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_e :: rest )
      equation
        txt = dumpExp(txt, i_e);
        txt = Tpl.nextIter(txt);
        txt = lm_122(txt, rest);
      then txt;
  end match;
end lm_122;

protected function lm_123
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_e;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_e :: rest )
      equation
        txt = dumpExp(txt, i_e);
        txt = Tpl.nextIter(txt);
        txt = lm_123(txt, rest);
      then txt;
  end match;
end lm_123;

public function dumpExp
  input Tpl.Text in_txt;
  input Absyn.Exp in_a_exp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_exp)
    local
      Tpl.Text txt;
      Absyn.Exp i_index;
      list<Absyn.Exp> i_exps;
      Absyn.Exp i_rest;
      Absyn.Exp i_head;
      Absyn.Ident i_id;
      Absyn.CodeNode i_code;
      list<Absyn.Exp> i_expressions;
      Absyn.Exp i_stop;
      Absyn.Exp i_step;
      Absyn.Exp i_start;
      list<list<Absyn.Exp>> i_matrix;
      list<Absyn.Exp> i_arrayExp;
      Absyn.ComponentRef i_function__;
      Absyn.FunctionArgs i_functionArgs;
      Absyn.Exp i_exp;
      Absyn.Operator i_op;
      Absyn.Exp i_exp2;
      Absyn.Exp i_e;
      Absyn.Exp i_exp1;
      Boolean i_value_2;
      Absyn.ComponentRef i_componentRef;
      String i_value_1;
      Integer i_value;
      Tpl.Text l_list__str;
      Tpl.Text l_rest__str;
      Tpl.Text l_head__str;
      Tpl.Text l_tuple__str;
      Tpl.Text l_stop__str;
      Tpl.Text l_step__str;
      Tpl.Text l_start__str;
      Tpl.Text l_matrix__str;
      Tpl.Text l_array__str;
      Tpl.Text l_func__str;
      String ret_6;
      Tpl.Text l_args__str;
      Tpl.Text l_exp__str;
      Tpl.Text l_op__str;
      Tpl.Text l_rhs__str;
      Tpl.Text l_lhs__str;
      String ret_0;

    case ( txt,
           Absyn.INTEGER(value = i_value) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("INTEGER("));
        txt = Tpl.writeStr(txt, intString(i_value));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.REAL(value = i_value_1) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("REAL(\"Util.escapeModelicaStringToCString("));
        txt = Tpl.writeStr(txt, i_value_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")\")"));
      then txt;

    case ( txt,
           Absyn.CREF(componentRef = i_componentRef) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CREF("));
        txt = dumpCref(txt, i_componentRef);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.STRING(value = i_value_1) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("STRING(\""));
        ret_0 = Util.escapeModelicaStringToCString(i_value_1);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           Absyn.BOOL(value = i_value_2) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BOOL("));
        txt = Tpl.writeStr(txt, Tpl.booleanString(i_value_2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_e as Absyn.BINARY(exp1 = i_exp1, exp2 = i_exp2, op = i_op)) )
      equation
        l_lhs__str = dumpOperand(Tpl.emptyTxt, i_exp1, i_e, true);
        l_rhs__str = dumpOperand(Tpl.emptyTxt, i_exp2, i_e, false);
        l_op__str = dumpOperator(Tpl.emptyTxt, i_op);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BINARY("));
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_op__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_e as Absyn.UNARY(exp = i_exp, op = i_op)) )
      equation
        l_exp__str = dumpOperand(Tpl.emptyTxt, i_exp, i_e, false);
        l_op__str = dumpOperator(Tpl.emptyTxt, i_op);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNARY("));
        txt = Tpl.writeText(txt, l_op__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_e as Absyn.LBINARY(exp1 = i_exp1, exp2 = i_exp2, op = i_op)) )
      equation
        l_lhs__str = dumpOperand(Tpl.emptyTxt, i_exp1, i_e, true);
        l_rhs__str = dumpOperand(Tpl.emptyTxt, i_exp2, i_e, false);
        l_op__str = dumpOperator(Tpl.emptyTxt, i_op);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LBINARY("));
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_op__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_e as Absyn.LUNARY(exp = i_exp, op = i_op)) )
      equation
        l_exp__str = dumpOperand(Tpl.emptyTxt, i_exp, i_e, false);
        l_op__str = dumpOperator(Tpl.emptyTxt, i_op);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LUNARY("));
        txt = Tpl.writeText(txt, l_op__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_e as Absyn.RELATION(exp1 = i_exp1, exp2 = i_exp2, op = i_op)) )
      equation
        l_lhs__str = dumpOperand(Tpl.emptyTxt, i_exp1, i_e, true);
        l_rhs__str = dumpOperand(Tpl.emptyTxt, i_exp2, i_e, false);
        l_op__str = dumpOperator(Tpl.emptyTxt, i_op);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RELATION("));
        txt = Tpl.writeText(txt, l_lhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_op__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rhs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_exp as Absyn.IFEXP(ifExp = _)) )
      equation
        txt = dumpIfExp(txt, i_exp);
      then txt;

    case ( txt,
           Absyn.CALL(function_ = Absyn.CREF_IDENT(name = "$array"), functionArgs = i_functionArgs) )
      equation
        l_args__str = dumpFunctionArgs(Tpl.emptyTxt, i_functionArgs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CALL(CREF_IDENT(\""));
        ret_6 = Util.escapeModelicaStringToCString("array");
        txt = Tpl.writeStr(txt, ret_6);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\") ,list("));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.CALL(function_ = i_function__, functionArgs = i_functionArgs) )
      equation
        l_func__str = dumpCref(Tpl.emptyTxt, i_function__);
        l_args__str = dumpFunctionArgs(Tpl.emptyTxt, i_functionArgs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CALL("));
        txt = Tpl.writeText(txt, l_func__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.PARTEVALFUNCTION(function_ = i_function__, functionArgs = i_functionArgs) )
      equation
        l_func__str = dumpCref(Tpl.emptyTxt, i_function__);
        l_args__str = dumpFunctionArgs(Tpl.emptyTxt, i_functionArgs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PARTEVALFUNCTION("));
        txt = Tpl.writeText(txt, l_func__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ARRAY(arrayExp = i_arrayExp) )
      equation
        l_array__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_array__str = lm_119(l_array__str, i_arrayExp);
        l_array__str = Tpl.popIter(l_array__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ARRAY(list("));
        txt = Tpl.writeText(txt, l_array__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.MATRIX(matrix = i_matrix) )
      equation
        l_matrix__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_matrix__str = lm_121(l_matrix__str, i_matrix);
        l_matrix__str = Tpl.popIter(l_matrix__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MATRIX(list("));
        txt = Tpl.writeText(txt, l_matrix__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           (i_e as Absyn.RANGE(step = SOME(i_step), start = i_start, stop = i_stop)) )
      equation
        l_start__str = dumpOperand(Tpl.emptyTxt, i_start, i_e, false);
        l_step__str = dumpOperand(Tpl.emptyTxt, i_step, i_e, false);
        l_stop__str = dumpOperand(Tpl.emptyTxt, i_stop, i_e, false);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RANGE("));
        txt = Tpl.writeText(txt, l_start__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", SOME("));
        txt = Tpl.writeText(txt, l_step__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_stop__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_e as Absyn.RANGE(step = NONE(), start = i_start, stop = i_stop)) )
      equation
        l_start__str = dumpOperand(Tpl.emptyTxt, i_start, i_e, false);
        l_stop__str = dumpOperand(Tpl.emptyTxt, i_stop, i_e, false);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RANGE("));
        txt = Tpl.writeText(txt, l_start__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", NONE(), "));
        txt = Tpl.writeText(txt, l_stop__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.TUPLE(expressions = i_expressions) )
      equation
        l_tuple__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, SOME(Tpl.ST_STRING("")), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_tuple__str = lm_122(l_tuple__str, i_expressions);
        l_tuple__str = Tpl.popIter(l_tuple__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("TUPLE(list("));
        txt = Tpl.writeText(txt, l_tuple__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.END() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END()"));
      then txt;

    case ( txt,
           Absyn.CODE(code = i_code) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CODE("));
        txt = dumpCodeNode(txt, i_code);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.AS(exp = i_exp, id = i_id) )
      equation
        l_exp__str = dumpExp(Tpl.emptyTxt, i_exp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("AS("));
        txt = Tpl.writeStr(txt, i_id);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.CONS(head = i_head, rest = i_rest) )
      equation
        l_head__str = dumpExp(Tpl.emptyTxt, i_head);
        l_rest__str = dumpExp(Tpl.emptyTxt, i_rest);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CONS("));
        txt = Tpl.writeText(txt, l_head__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_rest__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           (i_exp as Absyn.MATCHEXP(matchTy = _)) )
      equation
        txt = dumpMatchExp(txt, i_exp);
      then txt;

    case ( txt,
           Absyn.LIST(exps = i_exps) )
      equation
        l_list__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_list__str = lm_123(l_list__str, i_exps);
        l_list__str = Tpl.popIter(l_list__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LIST(list("));
        txt = Tpl.writeText(txt, l_list__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.DOT(exp = i_exp, index = i_index) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("DOT("));
        txt = dumpExp(txt, i_exp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpExp(txt, i_index);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/* AbsynDumpTpl.dumpExp: UNHANDLED Abyn.Exp */"));
      then txt;
  end match;
end dumpExp;

public function dumpLhsExp
  input Tpl.Text in_txt;
  input Absyn.Exp in_a_lhs;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_lhs)
    local
      Tpl.Text txt;
      Absyn.Exp i_lhs;

    case ( txt,
           (i_lhs as Absyn.IFEXP(ifExp = _)) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = dumpExp(txt, i_lhs);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           i_lhs )
      equation
        txt = dumpExp(txt, i_lhs);
      then txt;
  end match;
end dumpLhsExp;

public function dumpOperand
  input Tpl.Text txt;
  input Absyn.Exp a_operand;
  input Absyn.Exp a_operation;
  input Boolean a_lhs;

  output Tpl.Text out_txt;
algorithm
  out_txt := dumpExp(txt, a_operand);
end dumpOperand;

public function dumpIfExp
  input Tpl.Text in_txt;
  input Absyn.Exp in_a_if__exp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_if__exp)
    local
      Tpl.Text txt;
      list<tuple<Absyn.Exp, Absyn.Exp>> i_elseIfBranch;
      Absyn.Exp i_elseBranch;
      Absyn.Exp i_trueBranch;
      Absyn.Exp i_ifExp;
      Tpl.Text l_else__if__str;
      Tpl.Text l_else__branch__str;
      Tpl.Text l_true__branch__str;
      Tpl.Text l_cond__str;

    case ( txt,
           Absyn.IFEXP(ifExp = i_ifExp, trueBranch = i_trueBranch, elseBranch = i_elseBranch, elseIfBranch = i_elseIfBranch) )
      equation
        l_cond__str = dumpExp(Tpl.emptyTxt, i_ifExp);
        l_true__branch__str = dumpExp(Tpl.emptyTxt, i_trueBranch);
        l_else__branch__str = dumpExp(Tpl.emptyTxt, i_elseBranch);
        l_else__if__str = dumpElseIfExp(Tpl.emptyTxt, i_elseIfBranch);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("IFEXP("));
        txt = Tpl.writeText(txt, l_cond__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_true__branch__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_else__branch__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_else__if__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpIfExp;

protected function lm_128
  input Tpl.Text in_txt;
  input list<tuple<Absyn.Exp, Absyn.Exp>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<tuple<Absyn.Exp, Absyn.Exp>> rest;
      Absyn.Exp i_branch;
      Absyn.Exp i_cond;
      Tpl.Text l_branch__str;
      Tpl.Text l_cond__str;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_cond, i_branch) :: rest )
      equation
        l_cond__str = dumpExp(Tpl.emptyTxt, i_cond);
        l_branch__str = dumpExp(Tpl.emptyTxt, i_branch);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = Tpl.writeText(txt, l_cond__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_branch__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
        txt = Tpl.nextIter(txt);
        txt = lm_128(txt, rest);
      then txt;
  end match;
end lm_128;

public function dumpElseIfExp
  input Tpl.Text txt;
  input list<tuple<Absyn.Exp, Absyn.Exp>> a_else__if;

  output Tpl.Text out_txt;
protected
  Tpl.Text l_lst;
algorithm
  l_lst := Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  l_lst := lm_128(l_lst, a_else__if);
  l_lst := Tpl.popIter(l_lst);
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("list("));
  out_txt := Tpl.writeText(out_txt, l_lst);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(")"));
end dumpElseIfExp;

protected function fun_130
  input Tpl.Text in_txt;
  input Boolean in_a_boolean;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_boolean)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end fun_130;

protected function fun_131
  input Tpl.Text in_txt;
  input Boolean in_a_boolean;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_boolean)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end fun_131;

protected function fun_132
  input Tpl.Text in_txt;
  input Boolean in_a_boolean;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_boolean)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("false"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("true"));
      then txt;
  end match;
end fun_132;

public function dumpCodeNode
  input Tpl.Text in_txt;
  input Absyn.CodeNode in_a_code;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_code)
    local
      Tpl.Text txt;
      Absyn.Element i_element;
      Absyn.Modification i_modification;
      Absyn.Exp i_exp;
      list<Absyn.AlgorithmItem> i_algorithmItemLst;
      list<Absyn.EquationItem> i_equationItemLst;
      Boolean i_boolean;
      Tpl.Text l_algs__str;
      Tpl.Text l_eql__str;
      Tpl.Text l_equation__is__str;
      Tpl.Text l_initial__str;

    case ( txt,
           Absyn.C_TYPENAME(path = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_TYPENAME(dumpPath(path))"));
      then txt;

    case ( txt,
           Absyn.C_VARIABLENAME(componentRef = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_VARIABLENAME(dumpCref(componentRef))"));
      then txt;

    case ( txt,
           Absyn.C_CONSTRAINTSECTION(boolean = i_boolean, equationItemLst = i_equationItemLst) )
      equation
        l_initial__str = fun_130(Tpl.emptyTxt, i_boolean);
        l_equation__is__str = dumpEquationItems(Tpl.emptyTxt, i_equationItemLst);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_CONSTRAINTSECTION("));
        txt = Tpl.writeText(txt, l_initial__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_equation__is__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.C_EQUATIONSECTION(boolean = i_boolean, equationItemLst = i_equationItemLst) )
      equation
        l_initial__str = fun_131(Tpl.emptyTxt, i_boolean);
        l_eql__str = dumpEquationItems(Tpl.emptyTxt, i_equationItemLst);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_EQUATIONSECTION("));
        txt = Tpl.writeText(txt, l_initial__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_eql__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.C_ALGORITHMSECTION(boolean = i_boolean, algorithmItemLst = i_algorithmItemLst) )
      equation
        l_initial__str = fun_132(Tpl.emptyTxt, i_boolean);
        l_algs__str = dumpAlgorithmItems(Tpl.emptyTxt, i_algorithmItemLst);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_ALGORITHMSECTION("));
        txt = Tpl.writeText(txt, l_initial__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_algs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.C_EXPRESSION(exp = i_exp) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_EXPRESSION("));
        txt = dumpExp(txt, i_exp);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.C_MODIFICATION(modification = i_modification) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_MODIFICATION("));
        txt = dumpModification(txt, i_modification);
      then txt;

    case ( txt,
           Absyn.C_ELEMENT(element = i_element) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("C_ELEMENT("));
        txt = dumpElement(txt, i_element, Dump.defaultDumpOptions);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpCodeNode;

protected function lm_134
  input Tpl.Text in_txt;
  input list<Absyn.Case> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Case> rest;
      Absyn.Case i_c;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_c :: rest )
      equation
        txt = dumpMatchCase(txt, i_c);
        txt = Tpl.nextIter(txt);
        txt = lm_134(txt, rest);
      then txt;
  end match;
end lm_134;

public function dumpMatchExp
  input Tpl.Text in_txt;
  input Absyn.Exp in_a_match__exp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_match__exp)
    local
      Tpl.Text txt;
      Option<String> i_comment;
      list<Absyn.Case> i_cases;
      list<Absyn.ElementItem> i_localDecls;
      Absyn.Exp i_inputExp;
      Absyn.MatchType i_matchTy;
      Tpl.Text l_cmt__str;
      Tpl.Text l_cases__str;
      Tpl.Text l_locals__str;
      Tpl.Text l_input__str;
      Tpl.Text l_ty__str;

    case ( txt,
           Absyn.MATCHEXP(matchTy = i_matchTy, inputExp = i_inputExp, localDecls = i_localDecls, cases = i_cases, comment = i_comment) )
      equation
        l_ty__str = dumpMatchType(Tpl.emptyTxt, i_matchTy);
        l_input__str = dumpExp(Tpl.emptyTxt, i_inputExp);
        l_locals__str = dumpMatchLocals(Tpl.emptyTxt, i_localDecls);
        l_cases__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_cases__str = lm_134(l_cases__str, i_cases);
        l_cases__str = Tpl.popIter(l_cases__str);
        l_cmt__str = dumpStringCommentOption(Tpl.emptyTxt, i_comment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MATCHEXP("));
        txt = Tpl.writeText(txt, l_ty__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_input__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_locals__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cases__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpMatchExp;

public function dumpMatchType
  input Tpl.Text in_txt;
  input Absyn.MatchType in_a_match__type;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_match__type)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.MATCH() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MATCH()"));
      then txt;

    case ( txt,
           Absyn.MATCHCONTINUE() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MATCHCONTINUE()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpMatchType;

protected function lm_137
  input Tpl.Text in_txt;
  input list<Absyn.ElementItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementItem> rest;
      Absyn.ElementItem i_decl;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_decl :: rest )
      equation
        txt = dumpElementItem(txt, i_decl, Dump.defaultDumpOptions);
        txt = Tpl.nextIter(txt);
        txt = lm_137(txt, rest);
      then txt;
  end match;
end lm_137;

public function dumpMatchLocals
  input Tpl.Text in_txt;
  input list<Absyn.ElementItem> in_a_locals;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_locals)
    local
      Tpl.Text txt;
      list<Absyn.ElementItem> i_locals;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_locals )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("list("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_137(txt, i_locals);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end dumpMatchLocals;

protected function lm_139
  input Tpl.Text in_txt;
  input list<Absyn.EquationItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.EquationItem> rest;
      Absyn.EquationItem i_eq;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_eq :: rest )
      equation
        txt = dumpEquationItem(txt, i_eq);
        txt = Tpl.nextIter(txt);
        txt = lm_139(txt, rest);
      then txt;
  end match;
end lm_139;

protected function lm_140
  input Tpl.Text in_txt;
  input list<Absyn.AlgorithmItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> rest;
      Absyn.AlgorithmItem i_alg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_alg :: rest )
      equation
        txt = dumpAlgorithmItem(txt, i_alg);
        txt = Tpl.nextIter(txt);
        txt = lm_140(txt, rest);
      then txt;
  end match;
end lm_140;

public function dumpMatchEquations
  input Tpl.Text in_txt;
  input Absyn.ClassPart in_a_cp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cp)
    local
      Tpl.Text txt;
      list<Absyn.AlgorithmItem> i_algs;
      list<Absyn.EquationItem> i_eql;

    case ( txt,
           Absyn.EQUATIONS(contents = {}) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQUATIONS(list())"));
      then txt;

    case ( txt,
           Absyn.EQUATIONS(contents = i_eql) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQUATIONS("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_139(txt, i_eql);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ALGORITHMS(contents = {}) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALGORITHMS(list())"));
      then txt;

    case ( txt,
           Absyn.ALGORITHMS(contents = i_algs) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALGORITHMS("));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_140(txt, i_algs);
        txt = Tpl.popIter(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpMatchEquations;

protected function fun_142
  input Tpl.Text in_txt;
  input Option<Absyn.Exp> in_a_patternGuard;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_patternGuard)
    local
      Tpl.Text txt;
      Absyn.Exp i_g;

    case ( txt,
           SOME(i_g) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpExp(txt, i_g);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_142;

protected function lm_143
  input Tpl.Text in_txt;
  input list<Absyn.ElementItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementItem> rest;
      Absyn.ElementItem i_d;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_d :: rest )
      equation
        txt = dumpElementItem(txt, i_d, Dump.defaultDumpOptions);
        txt = Tpl.nextIter(txt);
        txt = lm_143(txt, rest);
      then txt;
  end match;
end lm_143;

protected function lm_144
  input Tpl.Text in_txt;
  input list<Absyn.ElementItem> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.ElementItem> rest;
      Absyn.ElementItem i_d;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_d :: rest )
      equation
        txt = dumpElementItem(txt, i_d, Dump.defaultDumpOptions);
        txt = Tpl.nextIter(txt);
        txt = lm_144(txt, rest);
      then txt;
  end match;
end lm_144;

public function dumpMatchCase
  input Tpl.Text in_txt;
  input Absyn.Case in_a_c;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_c)
    local
      Tpl.Text txt;
      SourceInfo i_info;
      Option<String> i_comment;
      SourceInfo i_resultInfo;
      Absyn.Exp i_result;
      Absyn.ClassPart i_classPart;
      list<Absyn.ElementItem> i_localDecls;
      SourceInfo i_patternInfo;
      Option<Absyn.Exp> i_patternGuard;
      Absyn.Exp i_pattern;
      Tpl.Text l_info__str;
      Tpl.Text l_i__str;
      Tpl.Text l_cmt__str;
      Tpl.Text l_r__i__str;
      Tpl.Text l_result__str;
      Tpl.Text l_eql__str;
      Tpl.Text l_local__decls__str;
      Tpl.Text l_p__info__str;
      Tpl.Text l_guard__str;
      Tpl.Text l_pattern__str;

    case ( txt,
           Absyn.CASE(pattern = i_pattern, patternGuard = i_patternGuard, patternInfo = i_patternInfo, localDecls = i_localDecls, classPart = i_classPart, result = i_result, resultInfo = i_resultInfo, comment = i_comment, info = i_info) )
      equation
        l_pattern__str = dumpExp(Tpl.emptyTxt, i_pattern);
        l_guard__str = fun_142(Tpl.emptyTxt, i_patternGuard);
        l_p__info__str = dumpInfo(Tpl.emptyTxt, i_patternInfo);
        l_local__decls__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_local__decls__str = lm_143(l_local__decls__str, i_localDecls);
        l_local__decls__str = Tpl.popIter(l_local__decls__str);
        l_eql__str = dumpMatchEquations(Tpl.emptyTxt, i_classPart);
        l_result__str = dumpExp(Tpl.emptyTxt, i_result);
        l_r__i__str = dumpInfo(Tpl.emptyTxt, i_resultInfo);
        l_cmt__str = dumpStringCommentOption(Tpl.emptyTxt, i_comment);
        l_i__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CASE("));
        txt = Tpl.writeText(txt, l_pattern__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_guard__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_p__info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", list("));
        txt = Tpl.writeText(txt, l_local__decls__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), "));
        txt = Tpl.writeText(txt, l_eql__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_result__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_r__i__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_i__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.ELSE(localDecls = i_localDecls, classPart = i_classPart, result = i_result, comment = i_comment, resultInfo = i_resultInfo, info = i_info) )
      equation
        l_local__decls__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_local__decls__str = lm_144(l_local__decls__str, i_localDecls);
        l_local__decls__str = Tpl.popIter(l_local__decls__str);
        l_eql__str = dumpMatchEquations(Tpl.emptyTxt, i_classPart);
        l_result__str = dumpExp(Tpl.emptyTxt, i_result);
        l_cmt__str = dumpStringCommentOption(Tpl.emptyTxt, i_comment);
        l_r__i__str = dumpInfo(Tpl.emptyTxt, i_resultInfo);
        l_info__str = dumpInfo(Tpl.emptyTxt, i_info);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ELSE("));
        txt = Tpl.writeText(txt, l_local__decls__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_eql__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_result__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_r__i__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_cmt__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_info__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpMatchCase;

public function dumpOperator
  input Tpl.Text in_txt;
  input Absyn.Operator in_a_op;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_op)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.ADD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ADD()"));
      then txt;

    case ( txt,
           Absyn.ADD_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ADD_EW()"));
      then txt;

    case ( txt,
           Absyn.AND() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("AND()"));
      then txt;

    case ( txt,
           Absyn.DIV() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("DIV()"));
      then txt;

    case ( txt,
           Absyn.DIV_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("DIV_EW()"));
      then txt;

    case ( txt,
           Absyn.EQUAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("EQUAL()"));
      then txt;

    case ( txt,
           Absyn.GREATER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GREATER()"));
      then txt;

    case ( txt,
           Absyn.GREATEREQ() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GREATEREQ()"));
      then txt;

    case ( txt,
           Absyn.LESS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LESS()"));
      then txt;

    case ( txt,
           Absyn.LESSEQ() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("LESSEQ()"));
      then txt;

    case ( txt,
           Absyn.MUL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MUL()"));
      then txt;

    case ( txt,
           Absyn.MUL_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MUL_EW()"));
      then txt;

    case ( txt,
           Absyn.NEQUAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NEQUAL()"));
      then txt;

    case ( txt,
           Absyn.NOT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOT()"));
      then txt;

    case ( txt,
           Absyn.OR() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("OR()"));
      then txt;

    case ( txt,
           Absyn.POW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("POW()"));
      then txt;

    case ( txt,
           Absyn.POW_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("POW_EW()"));
      then txt;

    case ( txt,
           Absyn.SUB() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SUB()"));
      then txt;

    case ( txt,
           Absyn.SUB_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SUB_EW()"));
      then txt;

    case ( txt,
           Absyn.UMINUS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UMINUS()"));
      then txt;

    case ( txt,
           Absyn.UMINUS_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UMINUS_EW()"));
      then txt;

    case ( txt,
           Absyn.UPLUS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UPLUS()"));
      then txt;

    case ( txt,
           Absyn.UPLUS_EW() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UPLUS_EW()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpOperator;

protected function fun_147
  input Tpl.Text in_txt;
  input Boolean in_mArg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_mArg)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("WILD()"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("WILD()"));
      then txt;
  end match;
end fun_147;

public function dumpCref
  input Tpl.Text in_txt;
  input Absyn.ComponentRef in_a_cref;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_cref)
    local
      Tpl.Text txt;
      Absyn.ComponentRef i_componentRef;
      list<Absyn.Subscript> i_subscripts;
      Absyn.Ident i_name;
      Boolean ret_2;
      String ret_1;
      String ret_0;

    case ( txt,
           Absyn.CREF_QUAL(name = i_name, subscripts = i_subscripts, componentRef = i_componentRef) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CREF_QUAL(\""));
        ret_0 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = dumpSubscripts(txt, i_subscripts);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpCref(txt, i_componentRef);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.CREF_IDENT(name = i_name, subscripts = i_subscripts) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CREF_IDENT(\""));
        ret_1 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = dumpSubscripts(txt, i_subscripts);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.CREF_FULLYQUALIFIED(componentRef = i_componentRef) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CREF_FULLYQUALIFIED("));
        txt = dumpCref(txt, i_componentRef);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           Absyn.WILD() )
      equation
        ret_2 = Config.acceptMetaModelicaGrammar();
        txt = fun_147(txt, ret_2);
      then txt;

    case ( txt,
           Absyn.ALLWILD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ALLWILD()"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpCref;

protected function lm_149
  input Tpl.Text in_txt;
  input list<Absyn.Exp> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.Exp> rest;
      Absyn.Exp i_arg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_arg :: rest )
      equation
        txt = dumpExp(txt, i_arg);
        txt = Tpl.nextIter(txt);
        txt = lm_149(txt, rest);
      then txt;
  end match;
end lm_149;

protected function lm_150
  input Tpl.Text in_txt;
  input list<Absyn.NamedArg> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<Absyn.NamedArg> rest;
      Absyn.NamedArg i_narg;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_narg :: rest )
      equation
        txt = dumpNamedArg(txt, i_narg);
        txt = Tpl.nextIter(txt);
        txt = lm_150(txt, rest);
      then txt;
  end match;
end lm_150;

protected function lm_151
  input Tpl.Text in_txt;
  input Absyn.ForIterators in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      Absyn.ForIterators rest;
      Absyn.ForIterator i_i;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_i :: rest )
      equation
        txt = dumpForIterator(txt, i_i);
        txt = Tpl.nextIter(txt);
        txt = lm_151(txt, rest);
      then txt;
  end match;
end lm_151;

protected function fun_152
  input Tpl.Text in_txt;
  input Absyn.ReductionIterType in_a_iterType;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_iterType)
    local
      Tpl.Text txt;

    case ( txt,
           Absyn.THREAD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("THREAD()"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("COMBINE()"));
      then txt;
  end match;
end fun_152;

public function dumpFunctionArgs
  input Tpl.Text in_txt;
  input Absyn.FunctionArgs in_a_args;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_args)
    local
      Tpl.Text txt;
      Absyn.ReductionIterType i_iterType;
      Absyn.ForIterators i_iterators;
      Absyn.Exp i_exp;
      list<Absyn.NamedArg> i_argNames;
      list<Absyn.Exp> i_args;
      Tpl.Text l_iter__type__str;
      Tpl.Text l_iter__str;
      Tpl.Text l_exp__str;
      Tpl.Text l_namedargs__str;
      Tpl.Text l_args__str;

    case ( txt,
           Absyn.FUNCTIONARGS(args = i_args, argNames = i_argNames) )
      equation
        l_args__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_args__str = lm_149(l_args__str, i_args);
        l_args__str = Tpl.popIter(l_args__str);
        l_namedargs__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_namedargs__str = lm_150(l_namedargs__str, i_argNames);
        l_namedargs__str = Tpl.popIter(l_namedargs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FUNCTIONARGS(list("));
        txt = Tpl.writeText(txt, l_args__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("), list("));
        txt = Tpl.writeText(txt, l_namedargs__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           Absyn.FOR_ITER_FARG(exp = i_exp, iterators = i_iterators, iterType = i_iterType) )
      equation
        l_exp__str = dumpExp(Tpl.emptyTxt, i_exp);
        l_iter__str = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_iter__str = lm_151(l_iter__str, i_iterators);
        l_iter__str = Tpl.popIter(l_iter__str);
        l_iter__type__str = fun_152(Tpl.emptyTxt, i_iterType);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FOR_ITER_FARG("));
        txt = Tpl.writeText(txt, l_exp__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_iter__type__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(","));
        txt = Tpl.writeText(txt, l_iter__str);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpFunctionArgs;

public function dumpNamedArg
  input Tpl.Text in_txt;
  input Absyn.NamedArg in_a_narg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_narg)
    local
      Tpl.Text txt;
      Absyn.Exp i_argValue;
      Absyn.Ident i_argName;

    case ( txt,
           Absyn.NAMEDARG(argName = i_argName, argValue = i_argValue) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NAMEDARG("));
        txt = Tpl.writeStr(txt, i_argName);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = dumpExp(txt, i_argValue);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpNamedArg;

protected function lm_155
  input Tpl.Text in_txt;
  input Absyn.ForIterators in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      Absyn.ForIterators rest;
      Absyn.ForIterator i_i;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_i :: rest )
      equation
        txt = dumpForIterator(txt, i_i);
        txt = Tpl.nextIter(txt);
        txt = lm_155(txt, rest);
      then txt;
  end match;
end lm_155;

public function dumpForIterators
  input Tpl.Text txt;
  input Absyn.ForIterators a_iters;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_155(out_txt, a_iters);
  out_txt := Tpl.popIter(out_txt);
end dumpForIterators;

protected function fun_157
  input Tpl.Text in_txt;
  input Option<Absyn.Exp> in_a_guardExp;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_guardExp)
    local
      Tpl.Text txt;
      Absyn.Exp i_x;

    case ( txt,
           SOME(i_x) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpExp(txt, i_x);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_157;

protected function fun_158
  input Tpl.Text in_txt;
  input Option<Absyn.Exp> in_a_range;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_range)
    local
      Tpl.Text txt;
      Absyn.Exp i_x;

    case ( txt,
           SOME(i_x) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SOME("));
        txt = dumpExp(txt, i_x);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NONE()"));
      then txt;
  end match;
end fun_158;

public function dumpForIterator
  input Tpl.Text in_txt;
  input Absyn.ForIterator in_a_iterator;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_iterator)
    local
      Tpl.Text txt;
      String i_name;
      Option<Absyn.Exp> i_range;
      Option<Absyn.Exp> i_guardExp;
      String ret_2;
      Tpl.Text l_re;
      Tpl.Text l_ge;

    case ( txt,
           Absyn.ITERATOR(guardExp = i_guardExp, range = i_range, name = i_name) )
      equation
        l_ge = fun_157(Tpl.emptyTxt, i_guardExp);
        l_re = fun_158(Tpl.emptyTxt, i_range);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ITERATOR(\""));
        ret_2 = Util.escapeModelicaStringToCString(i_name);
        txt = Tpl.writeStr(txt, ret_2);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\", "));
        txt = Tpl.writeText(txt, l_ge);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(", "));
        txt = Tpl.writeText(txt, l_re);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpForIterator;

public function errorMsg
  input Tpl.Text txt;
  input String a_errMessage;

  output Tpl.Text out_txt;
algorithm
  Tpl.addTemplateError(a_errMessage);
  out_txt := Tpl.writeStr(txt, a_errMessage);
end errorMsg;

annotation(__OpenModelica_Interface="frontend");
end AbsynJLDumpTpl;